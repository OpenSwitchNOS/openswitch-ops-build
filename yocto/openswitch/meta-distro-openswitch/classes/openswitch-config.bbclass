#
# Parse .ops-config file and convert config symbols to a format which build
# system understands.
#
# .ops-config is autogenerated by Kconfig system. Following holds true with
# respect to autogenerated Kconfig symbols for OpenSwitch:
#
#  - Disabled symbols are either not present or commented out (start with '#')
#  - All enabled symbols start with OPS_CONFIG_
#  - '=' separates symbols from values assigned.
#  - Enabled bool symbols end with '=y' and are added to IMAGE_FEATURES
#    provided they are part of the master mapping file.
#  - Enabled symbols not ending with '=y' are of type string/hex/int and
#    passed on to build system as key-value pairs.
#
# Current limitations of parser logic:
#  - Symbols of type 'tristate' (modules) are not supported
#


def get_ops_config_symbols(d):
    config_file_path = d.getVar("TOPDIR") + "/.ops-config"
    devenv_conf_file_path = \
        d.getVar("BUILD_ROOT") + \
        "/yocto/openswitch/meta-distro-openswitch/devenv.conf"
    debug_file_path = d.getVar("TOPDIR") + "/ops-mod-config.log"
    ops_feature = ""

    #
    # A note about logging:
    #
    # Apparently Python "logging" availability in yocto is under works:
    # https://bugzilla.yoctoproject.org/show_bug.cgi?id=2375
    #
    # bb.debug/warn/error/fatal/note are provided in logging.bbclass. But
    # they have limitations: can't handle arguments, interfere with regular
    # build console logs and they easily get lost in huge yocto build logs.
    #
    # So as of now creating a separate log file and dumping all relevant info
    # into it till a better way comes along.
    #
    debug_file = open(debug_file_path, "w")
    debug_file.write('==== Start OPS Modular Configuration logging ====\n')
    debug_file.write('DISTRO: ' + d.getVar("DISTRO") + '\n')
    debug_file.write('PLATFORM: ' + d.getVar("MACHINE") + '\n')
    debug_file.write('\n')

    # Configuration file generated by Kconfig system
    try:
        config_file = open(config_file_path, "r")
    except IOError:
        debug_file.write('Failed to open config file: ' +
                         config_file_path + '\n')
        debug_file.close()
        return ops_feature

    # devenv.conf file that contains all available packages
    try:
        devenv_conf_file = open(devenv_conf_file_path, "r")
    except IOError:
        debug_file.write('Failed to open devenv.conf file: ' +
                         devenv_conf_path + '\n')
        config_file.close()
        debug_file.close()
        return ops_feature

    # Dump .ops-config and devenv.conf into debug log
    debug_file.write('==== .ops-config contents ====\n')
    debug_file.write(config_file.read())
    config_file.seek(1)
    debug_file.write('\n')
    debug_file.write('==== devenv.conf contents ====\n')
    debug_file.write(devenv_conf_file.read())
    devenv_conf_file.seek(1)
    debug_file.write('\n')

    # Pick enabled symbols
    for line in config_file:
        line = line.strip()

        if line.startswith("OPS_CONFIG_"):
            # Get Kconfig symbol
            config_param = line.split('=', 1)

            if config_param[1] == 'y':
                # This is a feature
                config_symbol = config_param[0].split('_', 2)[2]
                ops_feature += config_symbol + " "
                debug_file.write('Feature: ' + config_symbol + '\n')

                # Map Kconfig feature symbol to package
                ops_package = config_symbol.lower()
                ops_package = ops_package.replace('_', '-')
                devenv_conf_file.seek(1)
                if ops_package not in devenv_conf_file.read():
                    ops_package = ""

                # Create empty FEATURE_PACKAGES for enabled symbols
                feature_package = "FEATURE_PACKAGES_" + config_symbol
                d.appendVar(feature_package, ops_package)
                debug_file.write('Package: ' + feature_package + ' ' +
                                 ops_package + '\n')
            else:
                # Key value pair. Add to data store
                config_symbol = config_param[0].split('_', 2)[2]
                d.setVar(config_symbol, config_param[1])
                debug_file.write('Key Value: ' + config_symbol + '=' +
                                 d.getVar(config_symbol) + '\n')

    debug_file.write('Full feature list: ' + ops_feature + '\n')
    config_file.close()
    devenv_conf_file.close()
    debug_file.close()
    return ops_feature


#
# Return full path to .ops-config that can be readily used by SRC_URI
# construct, if .ops-config file is present for a given distro-platform.
# Return "" if .ops-config file is not present
#
# Typically used by platform conf files to update IMAGE_FEATURES if there is
# any change in configuration
#


def get_ops_config_file(d):
    config_file_path = d.getVar("TOPDIR") + "/.ops-config"
    if os.path.isfile(config_file_path):
        return "file://${TOPDIR}/.ops-config"
    else:
        return ""
