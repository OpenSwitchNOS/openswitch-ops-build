From c1528eee979f5a50ba3435b59fbd9bb4c91b6144 Mon Sep 17 00:00:00 2001
From: Harshvardhan <harshvardhan@hpe.com>
Date: Tue, 21 Jun 2016 07:07:30 -0700
Subject: [PATCH] ops-utils call for setting and getting tag and trunked VLANs
 for port table

Tags: fix, dev
TG-1175

Change-Id: Id8b69a23470dabc2c67f47d7c2c2fe6ec810c41f
Signed-off-by: Harshvardhan <harshvardhan@hpe.com>
---
 utilities/ovs-vsctl.c | 105 ++++++++++++++++++++++++++++++++++++++++++++------
 1 file changed, 93 insertions(+), 12 deletions(-)

diff --git a/utilities/ovs-vsctl.c b/utilities/ovs-vsctl.c
index d404b8f..d200897 100644
--- a/utilities/ovs-vsctl.c
+++ b/utilities/ovs-vsctl.c
@@ -134,6 +134,89 @@ static struct uuid *neoteric_ifaces;
 static size_t n_neoteric_ifaces;
 static size_t allocated_neoteric_ifaces;
 
+const struct ovsrec_vlan * ops_get_vlan_by_id(int vlan_id,
+                                              struct ovsdb_idl *idl)
+{
+    const struct ovsrec_vlan *vlan_row = NULL;
+
+    if(idl != NULL) {
+        OVSREC_VLAN_FOR_EACH (vlan_row, idl) {
+            if(vlan_id == vlan_row->id) {
+                break;
+            }
+        }
+    }
+
+    return vlan_row;
+}
+
+bool ops_port_set_tag(int vlan_id,
+                      const struct ovsrec_port *port_row,
+                      struct ovsdb_idl *idl)
+{
+    const struct ovsrec_vlan *vlan_row = NULL;
+    bool ret_val = false;
+    int64_t tag = (int64_t)vlan_id;
+
+    if ((port_row != NULL ) && (idl != NULL)) {
+        if (vlan_id != 0) {
+            vlan_row = ops_get_vlan_by_id(vlan_id, idl);
+            if(vlan_row != NULL) {
+                ovsrec_port_set_vlan_tag(port_row, vlan_row);
+                ret_val = true;
+            }
+        }
+    }
+
+    return ret_val;
+}
+
+int ops_port_get_tag(const struct ovsrec_port *port_row)
+{
+    int vlan_id = 0;
+
+    if (port_row != NULL) {
+        if(port_row->vlan_tag != NULL) {
+            vlan_id = port_row->vlan_tag->id;
+        }
+    }
+
+    return vlan_id;
+}
+
+bool ops_mac_set_vlan(int64_t vlan_id,
+                      const struct ovsrec_mac *mac_row,
+                      struct ovsdb_idl *idl)
+{
+    const struct ovsrec_vlan *vlan_row = NULL;
+    bool ret_val = false;
+
+    if ((mac_row != NULL) && (idl != NULL)) {
+        if (vlan_id != 0) {
+            vlan_row = ops_get_vlan_by_id(vlan_id, idl);
+            if(vlan_row != NULL) {
+                ovsrec_mac_set_mac_vlan(mac_row, vlan_row);
+                ret_val = true;
+            }
+        }
+    }
+
+    return ret_val;
+}
+
+int ops_mac_get_vlan(const struct ovsrec_mac *mac_row)
+{
+    int vlan_id = 0;
+
+    if (mac_row != NULL) {
+        if(mac_row->mac_vlan != NULL) {
+            vlan_id = mac_row->mac_vlan->id;
+        }
+    }
+
+    return vlan_id;
+}
+
 int
 main(int argc, char *argv[])
 {
@@ -651,7 +734,7 @@ port_is_fake_bridge(const struct ovsrec_port *port_cfg)
 {
     return (port_cfg->fake_bridge
             && port_cfg->tag
-            && *port_cfg->tag >= 0 && *port_cfg->tag <= 4095);
+            && ops_port_get_tag(port_cfg) >= 0 && ops_port_get_tag(port_cfg) <= 4095);
 }
 #endif
 
@@ -707,11 +790,11 @@ add_port_to_cache(struct vsctl_context *vsctl_ctx, struct vsctl_bridge *parent,
 {
     struct vsctl_port *port;
 
-    if (port_cfg->tag
-        && *port_cfg->tag >= 0 && *port_cfg->tag <= 4095) {
+    if (port_cfg->vlan_tag
+        && ops_port_get_tag(port_cfg) >= 0 && ops_port_get_tag(port_cfg) <= 4095) {
         struct vsctl_bridge *vlan_bridge;
 
-        vlan_bridge = find_vlan_bridge(parent, *port_cfg->tag);
+        vlan_bridge = find_vlan_bridge(parent, ops_port_get_tag(port_cfg));
         if (vlan_bridge) {
             parent = vlan_bridge;
         }
@@ -845,7 +928,7 @@ pre_get_info(struct ctl_context *ctx)
 #ifndef OPS_TEMP
     ovsdb_idl_add_column(ctx->idl, &ovsrec_port_col_fake_bridge);
 #endif
-    ovsdb_idl_add_column(ctx->idl, &ovsrec_port_col_tag);
+    ovsdb_idl_add_column(ctx->idl, &ovsrec_port_col_vlan_tag);
     ovsdb_idl_add_column(ctx->idl, &ovsrec_port_col_interfaces);
 
     ovsdb_idl_add_column(ctx->idl, &ovsrec_interface_col_name);
@@ -921,7 +1004,7 @@ vsctl_context_populate_cache(struct ctl_context *ctx)
             if (port_is_fake_bridge(port_cfg)
                 && sset_add(&bridges, port_cfg->name)) {
                 add_bridge_to_cache(vsctl_ctx, NULL, port_cfg->name, br,
-                                    *port_cfg->tag);
+                                    ops_port_get_tag(port_cfg));
             }
 #endif
         }
@@ -1314,8 +1397,8 @@ static struct cmd_show_table cmd_show_tables[] = {
 #endif
     {&ovsrec_table_port,
      &ovsrec_port_col_name,
-     {&ovsrec_port_col_tag,
-      &ovsrec_port_col_trunks,
+     {&ovsrec_port_col_vlan_tag,
+      &ovsrec_port_col_vlan_trunks,
       &ovsrec_port_col_interfaces},
      {NULL, NULL, NULL}
     },
@@ -1703,7 +1786,6 @@ cmd_add_br(struct ctl_context *ctx)
         struct vsctl_bridge *parent;
         struct ovsrec_port *port;
         struct ovsrec_bridge *br;
-        int64_t tag = vlan;
 
         parent = find_bridge(vsctl_ctx, parent_name, false);
         if (parent && parent->parent) {
@@ -1727,7 +1809,7 @@ cmd_add_br(struct ctl_context *ctx)
         ovsrec_port_set_name(port, br_name);
         ovsrec_port_set_interfaces(port, &iface, 1);
         ovsrec_port_set_fake_bridge(port, true);
-        ovsrec_port_set_tag(port, &tag, 1);
+        ops_port_set_tag(vlan, port, ctx->idl);
 
         bridge_insert_port(br, port);
     }
@@ -2666,8 +2748,7 @@ add_port(struct ctl_context *ctx,
 #endif
 
     if (bridge->parent) {
-        int64_t tag = bridge->vlan;
-        ovsrec_port_set_tag(port, &tag, 1);
+        ops_port_set_tag(bridge->vlan, port, ctx->idl);
     }
 
     for (i = 0; i < n_settings; i++) {
-- 
1.9.1

