From a4b76e43f0358ac30a5d707d47c55ba034fc6771 Mon Sep 17 00:00:00 2001
From: "Marcelo E. Magallon" <marcelo.magallon@hpe.com>
Date: Mon, 13 Jun 2016 15:05:38 -0600
Subject: [PATCH 03/11] compound-indexes

---
 Makefile.am                   |   1 +
 Makefile.am.orig              | 393 +++++++++++++++++++++++++++++++++++
 README-compound-indexes.md    | 321 +++++++++++++++++++++++++++++
 lib/automake.mk               |   4 +
 lib/ovsdb-idl-provider.h      |   2 +
 lib/ovsdb-idl-provider.h.orig |  11 +
 lib/ovsdb-idl.c               | 377 +++++++++++++++++++++++++++++++++
 lib/ovsdb-idl.c.orig          | 470 +++++++++++++++++++++++++++++++++++++++++-
 lib/ovsdb-idl.h               |  63 ++++++
 lib/ovsdb-idl.h.orig          | 314 ++++++++++++++++++++++++++++
 lib/skiplist.c                | 292 ++++++++++++++++++++++++++
 lib/skiplist.h                |  53 +++++
 ovsdb/ovsdb-idlc.in           | 118 +++++++++++
 ovsdb/ovsdb-idlc.in.orig      | 100 +++++++++
 tests/.gitignore              |   1 +
 tests/automake.mk             |   2 +
 tests/library.at              |  11 +
 tests/test-skiplist.c         | 212 +++++++++++++++++++
 18 files changed, 2742 insertions(+), 3 deletions(-)
 create mode 100644 Makefile.am.orig
 create mode 100644 README-compound-indexes.md
 create mode 100644 lib/ovsdb-idl.h.orig
 create mode 100644 lib/skiplist.c
 create mode 100644 lib/skiplist.h
 create mode 100644 tests/test-skiplist.c

diff --git a/Makefile.am b/Makefile.am
index a2b2a35..4395840 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -93,6 +93,7 @@ docs = \
 	OPENFLOW-1.1+.md \
 	PORTING.md \
 	README.md \
+	README-compound-indexes.md \
 	README-lisp.md \
 	README-native-tunneling.md \
 	REPORTING-BUGS.md \
diff --git a/Makefile.am.orig b/Makefile.am.orig
new file mode 100644
index 0000000..a2b2a35
--- /dev/null
+++ b/Makefile.am.orig
@@ -0,0 +1,393 @@
+# Copyright (C) 2007-2015 Nicira, Inc.
+#
+# Copying and distribution of this file, with or without modification,
+# are permitted in any medium without royalty provided the copyright
+# notice and this notice are preserved.  This file is offered as-is,
+# without warranty of any kind.
+
+AUTOMAKE_OPTIONS = foreign subdir-objects
+ACLOCAL_AMFLAGS = -I m4
+if OPS
+SUBDIRS = libltdl
+else
+SUBDIRS = datapath libltdl
+endif
+
+AM_CPPFLAGS = $(SSL_CFLAGS)
+AM_LDFLAGS = $(SSL_LDFLAGS)
+AM_LDFLAGS += $(OVS_LDFLAGS)
+
+if WIN32
+AM_CPPFLAGS += -I $(top_srcdir)/include/windows
+AM_CPPFLAGS += -I $(top_srcdir)/datapath-windows/include
+AM_CPPFLAGS += $(PTHREAD_INCLUDES)
+AM_CPPFLAGS += $(MSVC_CFLAGS)
+AM_LDFLAGS += $(PTHREAD_LDFLAGS)
+AM_LDFLAGS += $(MSVC64_LDFLAGS)
+endif
+
+AM_CPPFLAGS += -I $(top_srcdir)/include
+AM_CPPFLAGS += -I $(top_builddir)/include
+AM_CPPFLAGS += -I $(top_srcdir)/lib
+AM_CPPFLAGS += -I $(top_builddir)/lib
+AM_CPPFLAGS += -I $(top_srcdir)/libltdl
+AM_CPPFLAGS += -I $(top_builddir)/libltdl
+
+AM_CPPFLAGS += $(SSL_INCLUDES)
+
+AM_CFLAGS = -Wstrict-prototypes -DOPS -DOPS_TEMP
+AM_CFLAGS += $(WARNING_FLAGS)
+AM_CFLAGS += $(OVS_CFLAGS)
+
+if DPDK_NETDEV
+AM_CFLAGS += -D_FILE_OFFSET_BITS=64
+endif
+
+if NDEBUG
+AM_CPPFLAGS += -DNDEBUG
+AM_CFLAGS += -fomit-frame-pointer
+endif
+
+if WIN32
+psep=";"
+else
+psep=":"
+endif
+# PYTHONDONTWRITEBYTECODE=yes keeps Python from creating .pyc and .pyo
+# files.  Creating .py[co] works OK for any given version of Open
+# vSwitch, but it causes trouble if you switch from a version with
+# foo/__init__.py into an (older) version with plain foo.py, since
+# foo/__init__.pyc will cause Python to ignore foo.py.
+run_python = \
+	PYTHONPATH=$(top_srcdir)/python$(psep)$$PYTHONPATH \
+	PYTHONDONTWRITEBYTECODE=yes $(PYTHON)
+
+ALL_LOCAL =
+BUILT_SOURCES =
+CLEANFILES =
+CLEAN_LOCAL =
+DISTCLEANFILES =
+PYCOV_CLEAN_FILES = build-aux/check-structs,cover
+
+# A list of Markdown-formatted documentation that will automatically be
+# included in the "make dist-docs" output.
+docs = \
+	CONTRIBUTING.md \
+	CodingStyle.md \
+	DESIGN.md \
+	FAQ.md \
+	INSTALL.md \
+	INSTALL.Debian.md \
+	INSTALL.Docker.md \
+	INSTALL.DPDK.md \
+	INSTALL.Fedora.md \
+	INSTALL.KVM.md \
+	INSTALL.Libvirt.md \
+	INSTALL.NetBSD.md \
+	INSTALL.RHEL.md \
+	INSTALL.SSL.md \
+	INSTALL.XenServer.md \
+	INSTALL.userspace.md \
+	INSTALL.Windows.md \
+	IntegrationGuide.md \
+	OPENFLOW-1.1+.md \
+	PORTING.md \
+	README.md \
+	README-lisp.md \
+	README-native-tunneling.md \
+	REPORTING-BUGS.md \
+	SECURITY.md \
+	TODO.md \
+	WHY-OVS.md
+EXTRA_DIST = \
+	$(docs) \
+	NOTICE \
+	.travis.yml \
+	.travis/build.sh \
+	.travis/prepare.sh \
+	appveyor.yml \
+	boot.sh \
+	build-aux/cccl \
+	build-aux/cksum-schema-check \
+	build-aux/calculate-schema-cksum \
+	build-aux/dist-docs \
+	build-aux/sodepends.pl \
+	build-aux/soexpand.pl \
+	build-aux/xml2nroff \
+	$(MAN_FRAGMENTS) \
+	$(MAN_ROOTS) \
+	Vagrantfile
+bin_PROGRAMS =
+sbin_PROGRAMS =
+bin_SCRIPTS =
+DIST_HOOKS =
+dist_man_MANS =
+dist_pkgdata_DATA =
+dist_pkgdata_SCRIPTS =
+dist_sbin_SCRIPTS =
+dist_scripts_SCRIPTS =
+dist_scripts_DATA =
+INSTALL_DATA_LOCAL =
+UNINSTALL_LOCAL =
+man_MANS =
+MAN_FRAGMENTS =
+MAN_ROOTS =
+noinst_DATA =
+noinst_HEADERS =
+lib_LTLIBRARIES =
+noinst_man_MANS =
+noinst_PROGRAMS =
+noinst_SCRIPTS =
+OVSIDL_BUILT =
+pkgdata_DATA =
+sbin_SCRIPTS =
+scripts_SCRIPTS =
+completion_SCRIPTS =
+scripts_DATA =
+SUFFIXES =
+check_DATA =
+check_SCRIPTS =
+pkgconfig_DATA =
+FLAKE8_PYFILES =
+
+scriptsdir = $(pkgdatadir)/scripts
+completiondir = $(sysconfdir)/bash_completion.d
+pkgconfigdir = $(libdir)/pkgconfig
+
+# This ensures that files added to EXTRA_DIST are always distributed,
+# even if they are inside an Automake if...endif conditional block that is
+# disabled by some particular "configure" run.  For more information, see:
+# http://article.gmane.org/gmane.comp.sysutils.automake.general/10891
+noinst_HEADERS += $(EXTRA_DIST)
+
+ro_c = echo '/* -*- mode: c; buffer-read-only: t -*- */'
+ro_shell = printf '\043 Generated automatically -- do not modify!    -*- buffer-read-only: t -*-\n'
+
+SUFFIXES += .in
+.in:
+	$(AM_V_GEN)$(PERL) $(srcdir)/build-aux/soexpand.pl -I$(srcdir) < $< | \
+	    sed \
+		-e 's,[@]PKIDIR[@],$(PKIDIR),g' \
+                -e 's,[@]LOGDIR[@],$(LOGDIR),g' \
+                -e 's,[@]DBDIR[@],$(DBDIR),g' \
+                -e 's,[@]PERL[@],$(PERL),g' \
+                -e 's,[@]PYTHON[@],$(PYTHON),g' \
+                -e 's,[@]RUNDIR[@],$(RUNDIR),g' \
+                -e 's,[@]VERSION[@],$(VERSION),g' \
+                -e 's,[@]localstatedir[@],$(localstatedir),g' \
+                -e 's,[@]pkgdatadir[@],$(pkgdatadir),g' \
+                -e 's,[@]sysconfdir[@],$(sysconfdir),g' \
+                -e 's,[@]bindir[@],$(bindir),g' \
+                -e 's,[@]sbindir[@],$(sbindir),g' \
+                -e 's,[@]abs_builddir[@],$(abs_builddir),g' \
+                -e 's,[@]abs_top_srcdir[@],$(abs_top_srcdir),g' \
+            > $@.tmp
+	@if head -n 1 $@.tmp | grep '#!' > /dev/null; then \
+	    chmod +x $@.tmp; \
+	fi
+	$(AM_V_at) mv $@.tmp $@
+
+SUFFIXES += .xml
+%: %.xml
+	$(AM_V_GEN)$(run_python) $(srcdir)/build-aux/xml2nroff $< > $@.tmp \
+		--version=$(VERSION) \
+		PKIDIR='$(PKIDIR)' \
+		LOGDIR='$(LOGDIR)' \
+		DBDIR='$(DBDIR)' \
+		PERL='$(PERL)' \
+		PYTHON='$(PYTHON)' \
+		RUNDIR='$(RUNDIR)' \
+		VERSION='$(VERSION)' \
+		localstatedir='$(localstatedir)' \
+		pkgdatadir='$(pkgdatadir)' \
+		sysconfdir='$(sysconfdir)' \
+		bindir='$(bindir)' \
+		sbindir='$(sbindir)'
+	$(AM_v_at)mv $@.tmp $@
+
+.PHONY: clean-pycov
+clean-pycov:
+	cd $(srcdir) && rm -f $(PYCOV_CLEAN_FILES)
+CLEAN_LOCAL += clean-pycov
+
+# If we're checked out from a Git repository, make sure that every
+# file that is in Git is distributed.
+#
+# We only enable this check when GNU make is in use because the
+# Makefile in datapath/linux, needed to get the list of files to
+# distribute, requires GNU make extensions.
+if GNU_MAKE
+#ALL_LOCAL += dist-hook-git
+#dist-hook-git: distfiles
+#	@if test -e $(srcdir)/.git && (git --version) >/dev/null 2>&1; then \
+#	  (cd datapath && $(MAKE) distfiles);				    \
+#	  (cat distfiles; sed 's|^|datapath/|' datapath/distfiles) |	    \
+#	    LC_ALL=C sort -u > all-distfiles;				    \
+#	  (cd $(srcdir) && git ls-files) | grep -v '\.gitignore$$' |	    \
+#	    LC_ALL=C sort -u > all-gitfiles;				    \
+#	  LC_ALL=C comm -1 -3 all-distfiles all-gitfiles > missing-distfiles; \
+#	  if test -s missing-distfiles; then				    \
+#	    echo "The following files are in git but not the distribution:"; \
+#	    cat missing-distfiles;					    \
+#	    exit 1;							    \
+#	  fi;								    \
+#	fi
+CLEANFILES += all-distfiles all-gitfiles missing-distfiles
+# The following is based on commands for the Automake "distdir" target.
+distfiles: Makefile
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t" | \
+          LC_ALL=C sort -u > $@
+CLEANFILES += distfiles
+endif
+.PHONY: dist-hook-git
+
+# Check that every .c file includes <config.h>.
+#ALL_LOCAL += config-h-check
+#config-h-check:
+#	@cd $(srcdir); \
+#	if test -e .git && (git --version) >/dev/null 2>&1 && \
+#	   git --no-pager grep -L '#include <config\.h>' `git ls-files | grep '\.c$$' | \
+#               grep -vE '^datapath|^lib/sflow|^third-party|^datapath-windows'`; \
+#	then \
+#	    echo "See above for list of violations of the rule that"; \
+#	    echo "every C source file must #include <config.h>."; \
+#	    exit 1; \
+#	fi
+.PHONY: config-h-check
+
+# Check for printf() type modifiers that MSVC doesn't support.
+ALL_LOCAL += printf-check
+printf-check:
+	@cd $(srcdir); \
+	if test -e .git && (git --version) >/dev/null 2>&1 && \
+	   git --no-pager grep -n -E -e '%[-+ #0-9.*]*([ztj]|hh)' --and --not -e 'ovs_scan' `git ls-files | grep '\.[ch]$$' | \
+               grep -vE '^datapath|^lib/sflow|^third-party'`; \
+	then \
+	    echo "See above for list of violations of the rule that"; \
+	    echo "'z', 't', 'j', 'hh' printf() type modifiers are"; \
+	    echo "forbidden.  See CodingStyle.md for replacements."; \
+	    exit 1; \
+	fi
+.PHONY: printf-check
+
+# Check that certain data structures are always declared "static".
+ALL_LOCAL += static-check
+static-check:
+	@if test -e $(srcdir)/.git && (git --version) >/dev/null 2>&1 && \
+	    git --no-pager grep -n -E '^[ 	]+(struct vlog_rate_limit|pthread_once_t|struct ovsthread_once).*=' $(srcdir); \
+         then \
+	    echo "See above for list of violations of the rule that "; \
+	    echo "certain data structures must always be 'static'"; \
+	    exit 1; \
+	 fi
+.PHONY: static-check
+
+# Check that assert.h is not used outside a whitelist of files.
+ALL_LOCAL += check-assert-h-usage
+check-assert-h-usage:
+	@if test -e $(srcdir)/.git && (git --version) >/dev/null 2>&1 && \
+	    (cd $(srcdir) && git --no-pager grep -l -E '[<]assert.h[>]') | \
+	    $(EGREP) -v '^lib/(sflow_receiver|vlog).c$$|^tests/'; \
+         then \
+	    echo "Files listed above unexpectedly #include <""assert.h"">."; \
+	    echo "Please use ovs_assert (from util.h) instead of assert."; \
+	    exit 1; \
+	 fi
+.PHONY: check-assert-h-usage
+
+# Check that LITTLE_ENDIAN and BIG_ENDIAN are not used unless BYTE_ORDER is
+# also mentioned.  (<endian.h> always defines the former two constants.  They
+# must be compared to BYTE_ORDER to get the machine's correct endianness.  But
+# it is better to use WORDS_BIGENDIAN.)
+ALL_LOCAL += check-endian
+check-endian:
+	@if test -e $(srcdir)/.git && (git --version) >/dev/null 2>&1 && \
+	    (cd $(srcdir) && git --no-pager grep -l -E \
+             -e 'BIG_ENDIAN|LITTLE_ENDIAN' --and --not -e 'BYTE_ORDER' | \
+	    $(EGREP) -v '^datapath/'); \
+         then \
+	    echo "See above for list of files that misuse LITTLE""_ENDIAN"; \
+	    echo "or BIG""_ENDIAN.  Please use WORDS_BIGENDIAN instead."; \
+	    exit 1; \
+	 fi
+.PHONY: check-endian
+
+#ALL_LOCAL += thread-safety-check
+#thread-safety-check:
+#	@cd $(srcdir); \
+#	if test -e .git && (git --version) >/dev/null 2>&1 && \
+#	   grep -n -f build-aux/thread-safety-blacklist \
+#	       `git ls-files | grep '\.[ch]$$' \
+#                | $(EGREP) -v '^datapath|^lib/sflow|^third-party'` /dev/null \
+#	       | $(EGREP) -v ':[ 	]*/?\*'; \
+#	then \
+#	    echo "See above for list of calls to functions that are"; \
+#	    echo "blacklisted due to thread safety issues"; \
+#	    exit 1; \
+#	fi
+EXTRA_DIST += build-aux/thread-safety-blacklist
+.PHONY: thread-safety-check
+
+if HAVE_GROFF
+ALL_LOCAL += manpage-check
+manpage-check: $(man_MANS) $(dist_man_MANS) $(noinst_man_MANS)
+	@error=false; \
+	for manpage in $?; do \
+		LANG=en_US.UTF-8 groff -w mac -w delim -w escape -w input -w missing -w tab -T utf8 -man -p -z $$manpage >$@.tmp 2>&1; \
+		if grep warning: $@.tmp; then error=:; fi; \
+		rm -f $@.tmp; \
+	done; \
+	if $$error; then exit 1; else touch $@; fi
+	$(AM_V_GEN) touch -c $@
+CLEANFILES += manpage-check
+endif
+
+include $(srcdir)/manpages.mk
+$(srcdir)/manpages.mk: $(MAN_ROOTS) build-aux/sodepends.pl
+	@$(PERL) $(srcdir)/build-aux/sodepends.pl -I. -I$(srcdir) $(MAN_ROOTS) >$(@F).tmp
+	@if cmp -s $(@F).tmp $@; then \
+		touch $@; \
+		rm -f $(@F).tmp; \
+	else \
+		mv $(@F).tmp $@; \
+	fi
+CLEANFILES += manpage-dep-check
+
+dist-hook: $(DIST_HOOKS)
+all-local: $(ALL_LOCAL)
+clean-local: $(CLEAN_LOCAL)
+install-data-local: $(INSTALL_DATA_LOCAL)
+uninstall-local: $(UNINSTALL_LOCAL)
+.PHONY: $(DIST_HOOKS) $(CLEAN_LOCAL) $(INSTALL_DATA_LOCAL) $(UNINSTALL_LOCAL)
+
+modules_install:
+if LINUX_ENABLED
+	cd datapath/linux && $(MAKE) modules_install
+endif
+
+dist-docs:
+	VERSION=$(VERSION) $(srcdir)/build-aux/dist-docs $(srcdir) $(docs)
+.PHONY: dist-docs
+
+if OPS
+nodist_ovslibincludedir = $(includedir)/ovs
+nodist_ovslibinclude_HEADERS = config.h
+#nodist_ovslibinclude_HEADERS += include/odp-netlink.h
+endif
+
+include m4/automake.mk
+include lib/automake.mk
+include ofproto/automake.mk
+include utilities/automake.mk
+include include/automake.mk
+if OVS_VSWITCHD
+include vswitchd/automake.mk
+endif
+include ovsdb/automake.mk
+include python/automake.mk
+include vtep/automake.mk
diff --git a/README-compound-indexes.md b/README-compound-indexes.md
new file mode 100644
index 0000000..054d965
--- /dev/null
+++ b/README-compound-indexes.md
@@ -0,0 +1,321 @@
+# Using indexes for special operations
+
+----------
+
+## Introduction
+
+The OVSDB database was designed for powering a virtual switch, therefore not all
+common DB functionality was needed at the time it was implemented. However, as
+part of the OpenSwitch project, developers found scenarios where this common
+functionality would be useful. One of this functionality is using indexes for
+operations such as sorting or fast lookup.
+
+This design document describes a proposed solution for implementing this extra
+functionality based on the concept of indexes.
+
+Please note that in this document, the term "index" refers to the common
+database term defined as "a data structure that improves data retrieval". Unless
+stated otherwise, the definition for index from the OVSDB RFC (RFC 7047) is not
+used.
+
+## Problem statement
+
+Some of the teams working on OpenSwitch would like to have available tools for
+special operations. This tools are not currently available on the OVSDB engine.
+
+The most common tools requested are for doing fast lookups of big tables and for
+a mechanism to retrieve data in lexicographic order.
+
+## Use cases
+
+### Fast lookups
+
+Depending on the topology, the route table of a network device could manage
+thousands of routes. Commands such as "show ip route <*specific route*>" would
+need to do a sequential lookup of the routing table to find the specific route.
+With an index created, the lookup time could be faster.
+
+This same scenario could be applied to other features such as Access List rules
+and even interfaces lists.
+
+### Lexicographic order
+
+There are several cases where retrieving data in lexicographic order is needed.
+For example, SNMP. When an administrator or even a NMS would like to retrieve
+data from a specific device, it's possible that they will request data from full
+tables instead of just specific values. Also, they would like to have this
+information displayed in lexicographic order. This operation could be done by
+the SNMP daemon or by the CLI, but it would be better if the database could
+provide the data ready for consumption. Also, duplicate efforts by different
+processes will be avoided. Another use case for requesting data in lexicographic
+order is for user interfaces (web or CLI) where it would be better and quicker
+if the DB sends the data sorted instead of letting each process to sort the data
+by itself.
+
+## Implementation
+
+The proposal is to create a data structure in memory that contains pointers to
+the rows where the desired information is stored. This data structure can be
+traversed in the order specified when creating the index.
+
+An index can be defined over any number of columns, and support the following
+options:
+
+-   Add a column with type string, int or real (using default comparators).
+-   Select ordering direction of a column (must be selected when creating the
+    index).
+-   Use a custom iterator (eg: treat a string column like a IP, or sort by the
+    value of "config" key in a map).
+
+For querying the index the user must create a cursor. That cursor points to a
+position in the sorted data structure. With that, the user can perform lookups
+(by key) and/or get the following rows. The user can also compare the current
+value of the cursor to a record.
+
+For faster lookups, user would need to provide a key which will be used for finding
+the specific rows that meet this criteria. This key could be an IP address, a
+MAC address, an ACL rule, etc. When the information is found in the data
+structure the user's cursor is updated to point to the row. If several rows
+match the query then the user can get easily the next row updating the cursor.
+
+For accessing data in lexicographic order, the user can use the ranged iterators.
+Those iterators needs a cursor, and a "from" and "to" value.
+
+One of the potential issues of this solution is the memory consumption of the
+new data structures. However, since it will only contain pointers, it's not
+expected that it consumes too much memory.
+
+Another potential issue is the time needed to create the data structure and the
+time needed to add/remove elements. The indexes are always synchronized with the
+replica. For this reason it must be important that the comparison functions
+(built-in and user provided) are FAST. However, these operations are not as
+common as looking up for data, so it's not expected these operations affects the
+system significatively.
+
+At this point, a skiplist is the data structure selected as the best fit.
+
+It's important to mention that all changes will be done in the IDL. There are no
+changes to the OVSDB server or the OVSDB engine.
+
+                     +---------------------------------------------------------+
+                     |                                                         |
+      +-----------------+Client changes to data                            IDL |
+      |              |                                                         |
+  +---v---+          |                                                         |
+  | OVSDB +------------->OVSDB Notification                                    |
+  +-------+          |   +                                                     |
+                     |   |   +------------+                                    |
+                     |   |   |            |                                    |
+                     |   |   | Insert Row +----> Insert row to indexes         |
+                     |   |   |            |                   ^                |
+                     |   +-> | Modify Row +-------------------+                |
+                     |       |            |                   v                |
+                     |       | Delete Row +----> Delete row from indexes       |
+                     |       |            |                                    |
+                     |       +----+-------+                                    |
+                     |            |                                            |
+                     |            +-> IDL Replica                              |
+                     |                                                         |
+                     +---------------------------------------------------------+
+
+## C IDL API
+
+This functionality is going to be implemented using the skiplist. A skiplist is
+a datastructure that offers log( n ) retrieval/insertions/deletions, and O(1)
+"find next" operations.
+
+To implement the indexes in the C IDL the following changes in the IDL are going
+to be made:
+
+-   Create a special function `int comparator(void*, void*)` per column, that
+    allows to compare two ovsrec structs (by that column).This function is
+    created only for the columns with type string, int or real. Each column has
+    a pointer to this function (or NULL).
+-   Each table, has a hash table with the indexes (keyed by index name).
+
+### Indexes
+
+The indexes are inserted in a hash table in each table in the IDL. This allow to
+specify any number of indexes per table, with a custom collection of columns.
+
+    /* Definition of the index's struct. It's a opaque type. */
+    struct ovsdb_idl_index {
+        struct skiplist *skiplist;
+        const struct ovsdb_idl_column **columns;
+        column_comparator *comparers;
+        int *sorting_order;
+        size_t n_columns;
+        bool row_sync;
+    };
+
+### Cursors
+
+The queries are going to be made with a cursor. A cursor is a struct that
+contains the current ovsrec, current node (on the skiplist) and memory allocated
+to save temporal records (needed by the comparator).
+
+    /* Definition of the cursor structure. */
+    struct ovsdb_idl_index_cursor {
+        struct ovsdb_idl_index *index;
+        struct skiplist_node *position;
+    };
+
+## API
+
+### Index Creation
+
+    struct ovsdb_idl_index *ovsdb_idl_create_index(
+        struct ovsdb_idl *idl,
+        const struct ovsdb_idl_table_class *tc,
+        const char *index_name
+    );
+
+Creates an index in a table. The columns must be configured afterwards. The
+returned pointer doesn't need to be saved anywhere, except until all the index's
+columns had been inserted.
+
+    void ovsdb_idl_index_add_column(struct ovsdb_idl_index *,
+                               const struct ovsdb_idl_column *,
+                               int order,
+                               column_comparator custom_comparer
+                               );
+
+Allows to add a column to an existing index. If the column has a default
+comparator then the custom comparator can be NULL, otherwise a custom comparator
+must be passed.
+
+#### Index Creation Example
+
+    /* Custom comparator for the column stringField at table Test */
+    int stringField_comparator(const void *a, const void *b) {
+        struct ovsrec_test *AAA, *BBB;
+        AAA = (struct ovsrec_test *)a;
+        BBB = (struct ovsrec_test *)b;
+        return strcmp(AAA->stringField, BBB->stringField);
+    }
+
+    void init_idl(struct ovsdb_idl **, char *remote) {
+        /* Add the columns to the IDL */
+        *idl = ovsdb_idl_create(remote, &ovsrec_idl_class, false, true);
+        ovsdb_idl_add_table(*idl, &ovsrec_table_test);
+        ovsdb_idl_add_column(*idl, &ovsrec_test_col_stringField);
+        ovsdb_idl_add_column(*idl, &ovsrec_test_col_numericField);
+        ovsdb_idl_add_column(*idl, &ovsrec_test_col_enumField);
+        ovsdb_idl_add_column(*idl, &ovsrec_test_col_boolField);
+
+        /* Create a index
+         * This index is created using (stringField, numericField) as key. Also shows the usage
+         * of some arguments of add column, althought for a string column is unnecesary to pass
+         * a custom comparator.
+         */
+        struct ovsdb_idl_index *index;
+        index = ovsdb_idl_create_index(*idl, &ovsrec_table_test, "by_stringField");
+        ovsdb_idl_index_add_column(index, &ovsrec_test_col_stringField, OVSDB_INDEX_ASC, stringField_comparator);
+        ovsdb_idl_index_add_column(index, &ovsrec_test_col_numericField, OVSDB_INDEX_DESC, NULL);
+        /* Done. */
+    }
+
+## Indexes Querying
+
+### Iterators
+
+The recommended way to do queries is using a "ranged foreach", an "equal
+foreach" or a "full foreach" over an index. The mechanism works as follow:
+
+1) Create a cursor 2) Pass the cursor, a row (ovsrec_...) and the values to the
+iterator 3) Use the values
+
+To create the cursor use the following code:
+
+    ovsdb_idl_index_cursor my_cursor;
+    ovsdb_idl_initialize_cursor(idl, &ovsrec_table_test, "by_stringField", &my_cursor);
+
+Then that cursor can be used to do additional queries. The library implements
+three different iterators: a range iterator, an equal iterator and iterator
+over all the index. The range iterator receives two values and iterates over
+all the records that are within that range (including both). The equal iterator
+only iterates over the records that exactly match the value passed. The full
+iterator iterates over all the rows in the index, in order.
+
+Note that the index are *sorted by the "concatenation" of the values in each
+indexed column*, so the ranged iterators returns all the values between
+"from.col1 from.col2 ... from.coln" and "to.col1 to.col2 ... to.coln", *NOT
+the rows with a value in column 1 between from.col1 and to.col1, and so on*.
+
+The iterators are macros especific to each table. To use those iterators
+consider the following code:
+
+    /* Equal Iterator
+     * Iterates over all the records equal to value (by the indexed value)
+     */
+    ovsrec_test *record;
+    ovsrec_test value;
+    value.stringField = "hello world";
+    OVSREC_TEST_FOR_EACH_EQUAL(record, &my_cursor, &value) {
+        /* Can return zero, one or more records */
+        assert(strcmp(record->stringField, "hello world") == 0);
+        printf("Found one record with %s", record->stringField);
+    }
+
+    /*
+     * Ranged iterator
+     * Iterates over all the records between two values (including both)
+     */
+    ovsrec_test value_from, value_to;
+    value_from.stringField = "aaa";
+    value_from.stringField = "mmm";
+    OVSREC_TEST_FOR_EACH_RANGE(record, &my_cursor, &value_from, &value_to) {
+        /* Can return zero, one or more records */
+        assert(strcmp("aaa", record->stringField) <= 0);
+        assert(strcmp(record->stringField, "mmm") <= 0);
+        printf("Found one record with %s", record->stringField);
+    }
+
+    /*
+     * Iterator over all the index
+     * Iterates over all the records in the index
+     */
+    OVSREC_TEST_FOR_EACH_BYINDEX(record, &my_cursor) {
+        /* Can return zero, one or more records */
+        printf("Found one record with %s", record->stringField);
+    }
+
+### General Index Access
+
+Although the iterators allow many use cases eventually thay may not fit some. In
+that case the indexes can be queried by a more general API. In fact, the
+iterators were built over that functions.
+
+    int ovsrec_<table>_index_compare(struct ovsdb_idl_index_cursor *, const struct ovsrec_<table> *, const struct ovsrec_<table> *)
+
+`ovsrec_<table>_index_compare` compares two rows using the same comparator used
+in the cursor's index. The returned value is the same as strcmp, but defines a
+specific behaviour when comparing pointers to NULL (NULL is always greater than
+any other value, but when comparing NULL against NULL by definition return 1).
+
+    const struct ovsrec_<table> *ovsrec_<table>_index_first(struct ovsdb_idl_index_cursor *)
+
+`ovsrec_<table>_index_next` moves the cursor to the first record in the index,
+and return the replica's pointer to that row.
+
+    const struct ovsrec_<table> *ovsrec_<table>_index_next(struct ovsdb_idl_index_cursor *)
+
+`ovsrec_<table>_index_next` moves the cursor to the next record in the index,
+and return the replica's pointer to that row. If the cursor was in the last row
+(or was already NULL) then returns NULL.
+
+    const struct ovsrec_<table> *ovsrec_<table>_index_find(struct ovsdb_idl_index_cursor *, const struct ovsrec_<table> *)
+
+`ovsrec_<table>_index_find` moves the cursor to the first record in the index
+that matches (by the index comparator) the given value, or NULL if none found.
+
+    const struct ovsrec_<table> *ovsrec_<table>_index_forward_to(struct ovsdb_idl_index_cursor *, const struct ovsrec_<table> *)
+
+`ovsrec_<table>_index_forward_to` moves the cursor to the first record in the
+index equal or greater than (by the index comparator) the given value, or NULL
+if none found.
+
+    const struct ovsrec_<table> *ovsrec_<table>_index_get_data(const struct ovsdb_idl_index_cursor *)
+
+`ovsrec_<table>_index_get_data` returns a pointer to the replica's row that is
+pointed by the cursor, or NULL.
diff --git a/lib/automake.mk b/lib/automake.mk
index 41944a8..e49f26f 100644
--- a/lib/automake.mk
+++ b/lib/automake.mk
@@ -138,6 +138,8 @@ ovslibinclude_HEADERS = \
 	lib/shash.h \
 	lib/signals.h \
 	lib/simap.h \
+	lib/skiplist.c \
+	lib/skiplist.h \
 	lib/smap.h \
 	lib/socket-util.h \
 	lib/sort.h \
@@ -286,6 +288,8 @@ lib_libovscommon_la_SOURCES = \
         lib/shash.h \
         lib/simap.c \
         lib/simap.h \
+	lib/skiplist.c \
+	lib/skiplist.h \
         lib/smap.c \
         lib/smap.h \
         lib/socket-util.c \
diff --git a/lib/ovsdb-idl-provider.h b/lib/ovsdb-idl-provider.h
index 1497135..b39674b 100644
--- a/lib/ovsdb-idl-provider.h
+++ b/lib/ovsdb-idl-provider.h
@@ -59,6 +59,7 @@ struct ovsdb_idl_column {
     bool mutable;
     void (*parse)(struct ovsdb_idl_row *, const struct ovsdb_datum *);
     void (*unparse)(struct ovsdb_idl_row *);
+    int (*compare)(const void *, const void *); /* Perform a comparison over ovsrec_* */
 #ifdef OPS
     unsigned int modify_seqno;
 #endif
@@ -87,6 +88,7 @@ struct ovsdb_idl_table {
     unsigned int delete_seqno;
 #endif
     unsigned int change_seqno[OVSDB_IDL_CHANGE_MAX];
+    struct shash indexes;    /* Contains "struct ovsdb_idl_index"s */
     struct ovs_list track_list; /* Tracked rows (ovsdb_idl_row.track_node). */
 
     bool has_pending_fetch;  /* Indicates if the table has a pending fetch
diff --git a/lib/ovsdb-idl-provider.h.orig b/lib/ovsdb-idl-provider.h.orig
index 399343e..1497135 100644
--- a/lib/ovsdb-idl-provider.h.orig
+++ b/lib/ovsdb-idl-provider.h.orig
@@ -47,7 +47,10 @@ struct ovsdb_idl_row {
 #endif
 
     unsigned int change_seqno[OVSDB_IDL_CHANGE_MAX];
+
     struct ovs_list track_node;
+    size_t outstanding_fetch_reqs; /* Number of on-demand columns in this row
+                                       with on-going fetch operations */
 };
 
 struct ovsdb_idl_column {
@@ -85,6 +88,14 @@ struct ovsdb_idl_table {
 #endif
     unsigned int change_seqno[OVSDB_IDL_CHANGE_MAX];
     struct ovs_list track_list; /* Tracked rows (ovsdb_idl_row.track_node). */
+
+    bool has_pending_fetch;  /* Indicates if the table has a pending fetch
+                                operation */
+    struct shash outstanding_col_fetch_reqs; /* Contains the name of the
+                                                columns with on-demand fetch
+                                                request pending. It does not
+                                                keep anything as data, just
+                                                the column names. */
 };
 
 struct ovsdb_idl_class {
diff --git a/lib/ovsdb-idl.c b/lib/ovsdb-idl.c
index e3c2401..52a8335 100644
--- a/lib/ovsdb-idl.c
+++ b/lib/ovsdb-idl.c
@@ -37,8 +37,10 @@
 #include "ovsdb-parser.h"
 #include "poll-loop.h"
 #include "shash.h"
+#include "skiplist.h"
 #include "sset.h"
 #include "util.h"
+#include "uuid.h"
 #include "openvswitch/vlog.h"
 
 VLOG_DEFINE_THIS_MODULE(ovsdb_idl);
@@ -210,6 +212,15 @@ ovsdb_idl_table_from_class(const struct ovsdb_idl *,
 static bool ovsdb_idl_track_is_set(struct ovsdb_idl_table *table);
 static struct json *where_uuid_equals(const struct uuid *uuid);
 
+static int
+ovsdb_idl_index_generic_comparer(const void *, const void *, const void *);
+static struct ovsdb_idl_index *
+ovsdb_idl_create_index_(const struct ovsdb_idl_table *table);
+static void
+ovsdb_idl_destroy_indexes(struct ovsdb_idl_table *table);
+static void ovsdb_idl_add_to_indexes(const struct ovsdb_idl_row *);
+static void ovsdb_idl_remove_from_indexes(const struct ovsdb_idl_row *);
+
 /* Creates and returns a connection to database 'remote', which should be in a
  * form acceptable to jsonrpc_session_open().  The connection will maintain an
  * in-memory replica of the remote database whose schema is described by
@@ -256,6 +267,7 @@ ovsdb_idl_create(const char *remote, const struct ovsdb_idl_class *class,
         memset(table->modes, default_mode, tc->n_columns);
         table->need_table = false;
         shash_init(&table->columns);
+        shash_init(&table->indexes);
         for (j = 0; j < tc->n_columns; j++) {
             const struct ovsdb_idl_column *column = &tc->columns[j];
 
@@ -295,6 +307,7 @@ ovsdb_idl_destroy(struct ovsdb_idl *idl)
 
         for (i = 0; i < idl->class->n_tables; i++) {
             struct ovsdb_idl_table *table = &idl->tables[i];
+            ovsdb_idl_destroy_indexes(table);
             shash_destroy(&table->columns);
             hmap_destroy(&table->rows);
             shash_destroy(&table->outstanding_col_fetch_reqs);
@@ -330,6 +343,7 @@ ovsdb_idl_clear(struct ovsdb_idl *idl)
             struct ovsdb_idl_arc *arc, *next_arc;
 
             if (!ovsdb_idl_row_is_orphan(row)) {
+                ovsdb_idl_remove_from_indexes(row);
                 ovsdb_idl_row_unparse(row);
             }
             LIST_FOR_EACH_SAFE (arc, next_arc, src_node, &row->src_arcs) {
@@ -1407,6 +1421,364 @@ ovsdb_idl_row_unparse(struct ovsdb_idl_row *row)
     }
 }
 
+/*
+ * Creates a new index, that is attached to the given idl and table.
+ * The index has the given name.
+ * All the indexes must be created before the first ovsdb_idl_run is
+ * executed.
+ */
+struct ovsdb_idl_index *
+ovsdb_idl_create_index(struct ovsdb_idl *idl,
+                       const struct ovsdb_idl_table_class *tc,
+                       const char *index_name)
+{
+    size_t i;
+    struct ovsdb_idl_index *index;
+    for(i = 0; i < idl->class->n_tables; i++){
+        struct ovsdb_idl_table *table = &idl->tables[i];
+
+        if (table->class == tc) {
+            index = ovsdb_idl_create_index_(table);
+            if(!shash_add_once(&table->indexes,
+                      index_name,
+                      index)){
+                VLOG_ERR("Can't repeat index name '%s' at table %s",
+                           index_name, table->class->name);
+                return NULL;
+            }
+            index->index_name = index_name;
+            return index;
+        }
+    }
+    OVS_NOT_REACHED();
+    return NULL;
+}
+
+static struct ovsdb_idl_index *
+ovsdb_idl_create_index_(const struct ovsdb_idl_table *table)
+{
+    struct ovsdb_idl_index *index;
+    size_t max_columns = table->class->n_columns;
+    index = malloc(sizeof(struct ovsdb_idl_index));
+    index->n_columns = 0;
+    index->alloc_columns = max_columns;
+    index->skiplist = skiplist_create(64, ovsdb_idl_index_generic_comparer,
+                                      index);
+    index->columns = malloc(max_columns * sizeof(struct ovsdb_idl_column *));
+    index->comparers = malloc(max_columns * sizeof(skiplist_comparator));
+    index->sorting_order = malloc(max_columns * sizeof(int));
+    index->row_sync = false;
+    index->table = table;
+    return index;
+}
+
+static void
+ovsdb_idl_destroy_indexes(struct ovsdb_idl_table *table)
+{
+    struct shash_node *node;
+    struct ovsdb_idl_index *index;
+    SHASH_FOR_EACH(node, &(table->indexes)){
+        index = (struct ovsdb_idl_index *)node->data;
+        skiplist_destroy(index->skiplist);
+        free(index->columns);
+        free(index->comparers);
+        free(index->sorting_order);
+    }
+}
+
+static void
+ovsdb_idl_add_to_indexes(const struct ovsdb_idl_row *row)
+{
+    struct ovsdb_idl_table *table = row->table;
+    struct ovsdb_idl_index *index;
+    struct shash_node *node;
+    SHASH_FOR_EACH(node, &(table->indexes)) {
+        index = (struct ovsdb_idl_index*) node->data;
+        index->row_sync = true;
+        skiplist_insert(index->skiplist, row);
+        index->row_sync = false;
+    }
+}
+
+static void
+ovsdb_idl_remove_from_indexes(const struct ovsdb_idl_row *row)
+{
+    struct ovsdb_idl_table *table = row->table;
+    struct ovsdb_idl_index *index;
+    struct shash_node *node;
+    SHASH_FOR_EACH(node, &(table->indexes)) {
+        index = (struct ovsdb_idl_index*) node->data;
+        index->row_sync = true;
+        skiplist_delete(index->skiplist, row);
+        index->row_sync = false;
+    }
+}
+
+/*
+ * Generic string comparer
+ */
+int
+ovsdb_idl_index_strcmp(char *data1, char *data2) {
+    return strcmp(data1, data2);
+}
+
+/*
+ * Generic int64_t comparer
+ */
+int
+ovsdb_idl_index_intcmp(int64_t a, int64_t b) {
+    return (a > b) - (a < b);
+}
+
+/*
+ * Generic float comparer
+ */
+int
+ovsdb_idl_index_doublecmp(double a, double b) {
+    return (a > b) - (a < b);
+}
+/*
+ * Adds a column to an existing index (all columns must be inserted before
+ * the first ovsdb_idl_run is executed).
+ * In "order", accepts the values OVSDB_INDEX_ASC or OVSDB_INDEX_DESC
+ * (OVSDB_INDEX_ASC by default).
+ * In "custom_comparer" it accepts a custom comparison function. If given NULL
+ * it will use the default comparator for the column (only available for
+ * string, numeric or real columns).
+ */
+void
+ovsdb_idl_index_add_column(struct ovsdb_idl_index *index,
+                           const struct ovsdb_idl_column *column,
+                           int order,
+                           column_comparator custom_comparer
+                           )
+{
+    /* Check that the column or table is tracked */
+    if(!index->table->need_table &&
+       !((OVSDB_IDL_MONITOR | OVSDB_IDL_ALERT) &
+         *ovsdb_idl_get_mode(index->table->idl, column))){
+        VLOG_ERR("Can't add column '%s' at index '%s' in "
+                   "table '%s'. Column isn't monitored.",
+                   column->name,
+                   index->index_name,
+                   index->table->class->name);
+    }
+
+    /* Allocate more memory for column configuration */
+    if(index->n_columns == index->alloc_columns){
+        index->alloc_columns++;
+        const struct ovsdb_idl_column **tmp_cols = malloc(index->alloc_columns);
+        column_comparator *tmp_cmps = malloc(index->alloc_columns);
+        int *tmp_order = malloc(index->alloc_columns);
+
+        memcpy(tmp_cols, index->columns,
+               index->n_columns * sizeof(struct ovsdb_idl_column *));
+        memcpy(tmp_cmps, index->comparers,
+                       index->n_columns * sizeof(column_comparator));
+        memcpy(tmp_order, index->sorting_order,
+                       index->n_columns * sizeof(int));
+
+        free(index->columns);
+        free(index->comparers);
+        free(index->sorting_order);
+
+        index->columns = tmp_cols;
+        index->comparers = tmp_cmps;
+        index->sorting_order = tmp_order;
+    }
+
+    /* Append column to index */
+    int i = index->n_columns;
+    index->columns[i] = column;
+    if(custom_comparer || column->compare) {
+        index->comparers[i] = custom_comparer ? custom_comparer :
+                          (column_comparator) column->compare;
+    } else {
+        VLOG_ERR("Column %s doesn't have default comparator, and"
+                   "no custom comparator was given.", column->name);
+    }
+    if(order == OVSDB_INDEX_ASC) {
+        index->sorting_order[i] = OVSDB_INDEX_ASC;
+    } else {
+        index->sorting_order[i] = OVSDB_INDEX_DESC;
+    }
+    index->n_columns++;
+}
+
+/*
+ * Initializes a index cursor
+ */
+bool
+ovsdb_idl_initialize_cursor(struct ovsdb_idl *idl,
+                            const struct ovsdb_idl_table_class *tc,
+                            const char *index_name,
+                            struct ovsdb_idl_index_cursor *cursor)
+{
+    size_t i;
+    for(i = 0; i < idl->class->n_tables; i++){
+        struct ovsdb_idl_table *table = &idl->tables[i];
+
+        if (table->class == tc) {
+            cursor->index = (struct ovsdb_idl_index *) shash_find(
+                                    &table->indexes,
+                                    index_name)->data;
+            if(!cursor->index) {
+                VLOG_ERR("Cursor initialization fails. "
+                        "Index %s at table %s doesn't exist.",
+                        index_name,
+                        tc->name);
+                cursor->index = NULL;
+                cursor->position = NULL;
+                return false;
+            }
+            cursor->position = skiplist_first(cursor->index->skiplist);
+            return true;
+        }
+    }
+    VLOG_ERR("Cursor initialization fails. "
+                "Index %s at table %s doesn't exist.",
+                index_name,
+                tc->name);
+    return false;
+}
+
+/*
+ * Generic comparator that can compare each index, using the custom
+ * configuration (an struct ovsdb_idl_index) passed to it.
+ * Not intended for direct usage.
+ */
+static int
+ovsdb_idl_index_generic_comparer(const void *a,
+                                 const void *b,
+                                 const void *conf)
+{
+    size_t i;
+    const struct ovsdb_idl_index *index = (const struct ovsdb_idl_index *)conf;
+
+    for(i = 0; i < index->n_columns; i++){
+        int val = index->comparers[i](a, b);
+        if(val){
+            return val * index->sorting_order[i];
+        }
+    }
+
+    /*
+     * If row_sync is true then the IDL is synchronization the replica's
+     * rows with the ones stored in the index. In this case is necessary
+     * to compare also by pointer value (eg: so the correct row is removed).
+     * In any other case (the user is doing a search) the values are
+     * already equal, so return 0.
+     * Also, the pointers obviously are random, so in different IDLs of the
+     * same OVSDB instance the index could have different ordering.
+     * Comparing first by UUID can guarantee the same order at any IDL.
+     */
+    if(index->row_sync){
+        const struct ovsdb_idl_row *row_a, *row_b;
+        row_a = (const struct ovsdb_idl_row *)a;
+        row_b = (const struct ovsdb_idl_row *)b;
+        int value = uuid_compare_3way(&row_a->uuid, &row_b->uuid);
+        return value ? value : (a < b) - (a > b);
+    } else {
+        return 0;
+    }
+}
+
+/*
+ * Moves the cursor to the first entry in the index.
+ * Returns a pointer to the corresponding ovsdb_idl_row, or NULL.
+ */
+struct ovsdb_idl_row *
+ovsdb_idl_index_first(struct ovsdb_idl_index_cursor *cursor)
+{
+    cursor->position = skiplist_first(cursor->index->skiplist);
+    return ovsdb_idl_index_data(cursor);
+}
+
+/*
+ * Moves the cursor to the following record in the index.
+ */
+struct ovsdb_idl_row *
+ovsdb_idl_index_next(struct ovsdb_idl_index_cursor *cursor)
+{
+    if(!cursor->position){
+        return NULL;
+    }
+    cursor->position = skiplist_next(cursor->position);
+    return ovsdb_idl_index_data(cursor);
+}
+
+/*
+ * Returns the ovsdb_idl_row pointer corresponding to the current record
+ */
+struct ovsdb_idl_row *
+ovsdb_idl_index_data(struct ovsdb_idl_index_cursor *cursor)
+{
+    return (struct ovsdb_idl_row *)skiplist_get_data(cursor->position);
+}
+
+/*
+ * Moves the cursor to the first entry with a value equal to the given value.
+ * If the value given is NULL then the function will behave like
+ * ovsdb_idl_index_first.
+ * Returns a pointer to the corresponding ovsdb_idl_row (that can be casted
+ * to a ovsrec) or NULL.
+ */
+struct ovsdb_idl_row *
+ovsdb_idl_index_find(struct ovsdb_idl_index_cursor *cursor,
+                     struct ovsdb_idl_row *value)
+{
+    if(value) {
+        cursor->position = skiplist_find(cursor->index->skiplist, value);
+    } else {
+        cursor->position = skiplist_first(cursor->index->skiplist);
+    }
+    return ovsdb_idl_index_data(cursor);
+}
+
+/*
+ * Moves the cursor to the first entry with a value greater or equal
+ * to the given value.
+ * If the value given is NULL then the function will behave like
+ * ovsdb_idl_index_first.
+ * Returns a pointer to the corresponding ovsdb_idl_row (that can be casted
+ * to a ovsrec) or NULL.
+ */
+struct ovsdb_idl_row *
+ovsdb_idl_index_forward_to(struct ovsdb_idl_index_cursor *cursor,
+                     struct ovsdb_idl_row *value)
+{
+    if(value) {
+        cursor->position = skiplist_forward_to(cursor->index->skiplist, value);
+    } else {
+        cursor->position = skiplist_first(cursor->index->skiplist);
+    }
+    return ovsdb_idl_index_data(cursor);
+}
+
+/*
+ * Returns the result of comparing two ovsrecs (casted to ovsdb_idl_row),
+ * using the comparer defined in the index.
+ * Returns:
+ * < 0 if a < b
+ * 0 if a == b
+ * > 0 if a > b
+ * When some input is NULL this function considers NULL to be greater than
+ * any other value. NULL compared to NULL returns 1.
+ */
+int
+ovsdb_idl_index_compare(struct ovsdb_idl_index_cursor *cursor,
+                        struct ovsdb_idl_row *a, struct ovsdb_idl_row *b)
+{
+    if(a && b) {
+        return ovsdb_idl_index_generic_comparer(a, b, cursor->index);
+    } else if(a) {
+        return -1;
+    } else {
+        /* If cmp(NULL, b) or cmp(NULL, NULL) */
+        return 1;
+    }
+}
+
 static void
 ovsdb_idl_row_clear_old(struct ovsdb_idl_row *row)
 {
@@ -1596,11 +1968,14 @@ ovsdb_idl_insert_row(struct ovsdb_idl_row *row, const struct json *row_json)
                       = row->table->modify_seqno
                       = (row->table->idl->change_seqno + 1);
 #endif
+
+    ovsdb_idl_add_to_indexes(row);
 }
 
 static void
 ovsdb_idl_delete_row(struct ovsdb_idl_row *row)
 {
+    ovsdb_idl_remove_from_indexes(row);
     ovsdb_idl_row_unparse(row);
     ovsdb_idl_row_clear_arcs(row, true);
     ovsdb_idl_row_clear_old(row);
@@ -1621,10 +1996,12 @@ ovsdb_idl_modify_row(struct ovsdb_idl_row *row, const struct json *row_json)
 {
     bool changed;
 
+    ovsdb_idl_remove_from_indexes(row);
     ovsdb_idl_row_unparse(row);
     ovsdb_idl_row_clear_arcs(row, true);
     changed = ovsdb_idl_row_update(row, row_json, OVSDB_IDL_CHANGE_MODIFY);
     ovsdb_idl_row_parse(row);
+    ovsdb_idl_add_to_indexes(row);
 
 #ifdef OPS
     if( changed )
diff --git a/lib/ovsdb-idl.c.orig b/lib/ovsdb-idl.c.orig
index 3701c6d..e3c2401 100644
--- a/lib/ovsdb-idl.c.orig
+++ b/lib/ovsdb-idl.c.orig
@@ -76,6 +76,15 @@ struct ovsdb_idl_arc {
     struct ovsdb_idl_row *dst;  /* Destination row. */
 };
 
+/* Keeps the information of fetch request for on-demand fetch columns. */
+struct ovsdb_idl_fetch_node {
+   struct hmap_node hmap_node;      /* To store this structure in hmaps */
+   struct shash columns;            /* Contains the columns requested */
+   struct ovsdb_idl_table *table;   /* Pointer to the requested table */
+   enum ovsdb_idl_fetch_type fetch_type; /* Type of the request: row, column
+                                            or table */
+};
+
 enum ovsdb_idl_state {
     IDL_S_SCHEMA_REQUESTED,
     IDL_S_MONITOR_REQUESTED,
@@ -104,6 +113,10 @@ struct ovsdb_idl {
     /* Transaction support. */
     struct ovsdb_idl_txn *txn;
     struct hmap outstanding_txns;
+
+    /* On-demand fetch. */
+    struct hmap outstanding_fetch_reqs; /* Contains the data of the
+                                           on-going fetch requests */
 };
 
 struct ovsdb_idl_txn {
@@ -148,6 +161,13 @@ static bool ovsdb_idl_process_update(struct ovsdb_idl_table *,
                                      const struct uuid *,
                                      const struct json *old,
                                      const struct json *new);
+static void ovsdb_idl_parse_fetch_reply(struct ovsdb_idl *,
+                                        struct hmap_node *,
+                                        const struct json *);
+static struct ovsdb_error *ovsdb_idl_parse_fetch_reply__(
+                                     struct ovsdb_idl *,
+                                     struct ovsdb_idl_fetch_node *,
+                                     const struct json *);
 static void ovsdb_idl_insert_row(struct ovsdb_idl_row *, const struct json *);
 static void ovsdb_idl_delete_row(struct ovsdb_idl_row *);
 static bool ovsdb_idl_modify_row(struct ovsdb_idl_row *, const struct json *);
@@ -188,6 +208,7 @@ static struct ovsdb_idl_table *
 ovsdb_idl_table_from_class(const struct ovsdb_idl *,
                            const struct ovsdb_idl_table_class *);
 static bool ovsdb_idl_track_is_set(struct ovsdb_idl_table *table);
+static struct json *where_uuid_equals(const struct uuid *uuid);
 
 /* Creates and returns a connection to database 'remote', which should be in a
  * form acceptable to jsonrpc_session_open().  The connection will maintain an
@@ -242,6 +263,7 @@ ovsdb_idl_create(const char *remote, const struct ovsdb_idl_class *class,
         }
         hmap_init(&table->rows);
         list_init(&table->track_list);
+        shash_init(&table->outstanding_col_fetch_reqs);
         table->change_seqno[OVSDB_IDL_CHANGE_INSERT]
             = table->change_seqno[OVSDB_IDL_CHANGE_MODIFY]
             = table->change_seqno[OVSDB_IDL_CHANGE_DELETE] = 0;
@@ -255,6 +277,7 @@ ovsdb_idl_create(const char *remote, const struct ovsdb_idl_class *class,
     idl->request_id = NULL;
 
     hmap_init(&idl->outstanding_txns);
+    hmap_init(&idl->outstanding_fetch_reqs);
 
     return idl;
 }
@@ -274,6 +297,7 @@ ovsdb_idl_destroy(struct ovsdb_idl *idl)
             struct ovsdb_idl_table *table = &idl->tables[i];
             shash_destroy(&table->columns);
             hmap_destroy(&table->rows);
+            shash_destroy(&table->outstanding_col_fetch_reqs);
             free(table->modes);
         }
         shash_destroy(&idl->table_by_name);
@@ -282,6 +306,7 @@ ovsdb_idl_destroy(struct ovsdb_idl *idl)
         free(idl->lock_name);
         json_destroy(idl->lock_request_id);
         hmap_destroy(&idl->outstanding_txns);
+        hmap_destroy(&idl->outstanding_fetch_reqs);
         free(idl);
     }
 }
@@ -335,6 +360,7 @@ void
 ovsdb_idl_run(struct ovsdb_idl *idl)
 {
     int i;
+    struct hmap_node *fetch_node;
 
     ovs_assert(!idl->txn);
     jsonrpc_session_run(idl->session);
@@ -369,7 +395,14 @@ ovsdb_idl_run(struct ovsdb_idl *idl)
             /* Database contents changed. */
             ovsdb_idl_parse_update(idl, msg->params->u.array.elems[1]);
         } else if (msg->type == JSONRPC_REPLY
-                   && idl->request_id
+                   && msg->result->type == JSON_ARRAY
+                   && (fetch_node = hmap_first_with_hash(
+                                        &idl->outstanding_fetch_reqs,
+                                        json_hash(msg->id, 0))) != NULL) {
+            /* On-demand fetch reply received. */
+            ovsdb_idl_parse_fetch_reply(idl, fetch_node, msg->result->u.array.elems[0]);
+        } else if (msg->type == JSONRPC_REPLY
+                  && idl->request_id
                    && json_equal(idl->request_id, msg->id)) {
             switch (idl->state) {
             case IDL_S_SCHEMA_REQUESTED:
@@ -549,6 +582,26 @@ add_ref_table(struct ovsdb_idl *idl, const struct ovsdb_base_type *base)
     }
 }
 
+/*
+ * Turns on OVSDB_IDL_MANUAL_FETCH for 'column' in 'idl'. Columns in this mode
+ * are not synchronized automatically.
+ *
+ * In order to get its value from the database, it is necessary to explicitly
+ * ask them from the server by calling one of this functions:
+ * ovsdb_idl_fetch_row, ovsdb_idl_fetch_column, or ovsdb_idl_fetch_table.
+ *
+ * This function adds the table with table class 'tc' to the replica (see
+ * ovsdb_idl_add_table() for more information)
+ */
+void
+ovsdb_idl_add_on_demand_column(struct ovsdb_idl *idl,
+                               struct ovsdb_idl_table_class *tc,
+                               const struct ovsdb_idl_column *column)
+{
+    ovsdb_idl_add_table(idl, tc);
+    *ovsdb_idl_get_mode(idl, column) = OVSDB_IDL_ON_DEMAND;
+}
+
 /* Turns on OVSDB_IDL_MONITOR and OVSDB_IDL_ALERT for 'column' in 'idl'.  Also
  * ensures that any tables referenced by 'column' will be replicated, even if
  * no columns in that table are selected for replication (see
@@ -1015,6 +1068,150 @@ ovsdb_idl_parse_update__(struct ovsdb_idl *idl,
     return NULL;
 }
 
+/* Processes an on-demand fetch request.
+ * 'pending_node' is a pointer to the request associated to the 'fetch_reply'.
+ * This function changes the IDL seqno.
+ */
+static void
+ovsdb_idl_parse_fetch_reply(struct ovsdb_idl *idl,
+                            struct hmap_node *pending_node,
+                            const struct json *fetch_reply)
+{
+
+    struct ovsdb_error *error = NULL;
+    struct ovsdb_idl_fetch_node *fetch_node;
+    /* Retrive the fetch node from the pending fetch hash */
+    fetch_node = CONTAINER_OF(pending_node, struct ovsdb_idl_fetch_node,
+            hmap_node);
+
+    if (fetch_reply->type != JSON_OBJECT) {
+        error = ovsdb_syntax_error(fetch_reply, NULL,
+                "<fetch_reply> is not an object");
+    } else {
+        error = ovsdb_idl_parse_fetch_reply__(idl, fetch_node, fetch_reply);
+    }
+
+    hmap_remove(&idl->outstanding_fetch_reqs, pending_node);
+    shash_destroy(&fetch_node->columns);
+    free(pending_node);
+
+    if (error) {
+        if (!VLOG_DROP_WARN(&syntax_rl)) {
+            char *s = ovsdb_error_to_string(error);
+            VLOG_WARN_RL(&syntax_rl, "%s", s);
+            free(s);
+        }
+        ovsdb_error_destroy(error);
+        return;
+    }
+
+    idl->change_seqno++;
+}
+
+/* Parses the JSON reply and updates the local replica.
+ * It clears the pending fetch flag of the row, column, or table fetched.
+ */
+static struct ovsdb_error *
+ovsdb_idl_parse_fetch_reply__(struct ovsdb_idl *idl,
+                              struct ovsdb_idl_fetch_node *fetch_node,
+                              const struct json* fetch_reply)
+{
+    struct uuid uuid;
+    const struct json_array *array;
+    const struct json *uuid_array;
+    const struct json *column_value;
+    struct ovsdb_datum column_data;
+    struct ovsdb_idl_row *row;
+    struct ovsdb_idl_column *column = NULL;
+    struct shash_node *shash_node;
+    struct ovsdb_idl_table *table = fetch_node->table;
+    unsigned int column_idx;
+    struct ovsdb_datum *old;
+
+    if (fetch_reply->type != JSON_OBJECT) {
+        return ovsdb_syntax_error(fetch_reply, NULL,
+               "<fetch_reply> is not an object");
+    }
+
+    /* Parse the json reply and get the UUID and value of the fetched column */
+    struct json_array *rows_array = json_array(shash_find_data(json_object(fetch_reply), "rows"));
+    for (int i = 0; i < rows_array->n; ++i) {
+        /* Read the uuid of the fetched row */
+        uuid_array = shash_find_data(json_object(rows_array->elems[i]), "_uuid");
+        if (!uuid_array || uuid_array->type != JSON_ARRAY) {
+            return ovsdb_syntax_error(fetch_reply, NULL,
+                    "Fetch reply for table %s does not include "
+                    "the UUID of the row", table->class->name);
+        }
+
+        array = json_array(uuid_array);
+        if (array->n != 2 || array->elems[1]->type != JSON_STRING
+                || !uuid_from_string(&uuid, array->elems[1]->u.string)) {
+            return ovsdb_syntax_error(fetch_reply, NULL,
+                    "Fetch reply for table %s contains bad UUID", table->class->name);
+        }
+
+        row = CONST_CAST(struct ovsdb_idl_row *,
+                ovsdb_idl_get_row_for_uuid(idl, fetch_node->table->class,
+                    &uuid));
+
+        /* If the row was deleted before the fetch reply was received,
+         * then there is no need to process the reply */
+        if (row != NULL) {
+            SHASH_FOR_EACH(shash_node, &fetch_node->columns) {
+                column = shash_node->data;
+                /* Read the fetched value */
+                column_value = shash_find_data(json_object(rows_array->elems[i]),
+                                               column->name);
+                if (!column_value) {
+                    return ovsdb_syntax_error(fetch_reply, NULL,
+                            "Fetch reply for table %s does not include "
+                            "the requested table value", table->class->name);
+                }
+
+                if (ovsdb_datum_from_json(&column_data, &column->type,
+                            column_value, NULL) != NULL) {
+                    /* In case this was a column request, remove it from the
+                     * outstanding_col_fetch_reqs */
+                    if (fetch_node->fetch_type == OVSDB_IDL_COLUMN_FETCH) {
+                        shash_find_and_delete(&table->outstanding_col_fetch_reqs,
+                                              column->name);
+                    }
+
+                    return ovsdb_syntax_error(fetch_reply, NULL,
+                            "Fetch reply for column %s contains bad column value",
+                            column->name);
+                }
+
+                /* Update the row */
+                column_idx = column - table->class->columns;
+                old = &row->old[column_idx];
+
+                if (!ovsdb_datum_equals(old, &column_data, &column->type)) {
+                    column->parse(row, &column_data);
+                    ovsdb_datum_swap(old, &column_data);
+                }
+
+                ovsdb_datum_destroy(&column_data, &column->type);
+                if (fetch_node->fetch_type == OVSDB_IDL_ROW_FETCH) {
+                    row->outstanding_fetch_reqs--;
+                }
+            }
+        }
+    }
+
+    if (fetch_node->fetch_type == OVSDB_IDL_COLUMN_FETCH && column) {
+        shash_find_and_delete(&table->outstanding_col_fetch_reqs, column->name);
+    }
+
+
+    if (fetch_node->fetch_type == OVSDB_IDL_TABLE_FETCH && table) {
+        table->has_pending_fetch = false;
+    }
+
+    return NULL;
+}
+
 static struct ovsdb_idl_row *
 ovsdb_idl_get_row(struct ovsdb_idl_table *table, const struct uuid *uuid)
 {
@@ -1303,6 +1500,7 @@ ovsdb_idl_row_create__(const struct ovsdb_idl_table_class *class)
     list_init(&row->dst_arcs);
     hmap_node_nullify(&row->txn_node);
     list_init(&row->track_node);
+    row->outstanding_fetch_reqs = 0;
     return row;
 }
 
@@ -1617,6 +1815,271 @@ ovsdb_idl_get(const struct ovsdb_idl_row *row,
     return ovsdb_idl_read(row, column);
 }
 
+/* Return true if any column of 'row' has a pending fetch operation.
+ *
+ * This function only considers on-demand requests done explicitly over 'row'
+ * i.e. after calling ovsdb_idl_fetch_row().
+ */
+bool
+ovsdb_idl_is_row_fetch_pending(const struct ovsdb_idl_row *row)
+{
+    return row->outstanding_fetch_reqs > 0;
+}
+
+/* Return true if 'column' has a pending fetch operation
+ *
+ * This function only considers on-demand requests done explicitly over
+ * 'column' i.e. after calling ovsdb_idl_fetch_column().
+ *
+ * It does not take into account rows requests.
+ */
+bool
+ovsdb_idl_is_column_fetch_pending(struct ovsdb_idl *idl,
+                                  const struct ovsdb_idl_table_class *tc,
+                                  const struct ovsdb_idl_column *column) {
+    struct shash_node *shash_node;
+    struct ovsdb_idl_table *table;
+    shash_node = shash_find(&idl->table_by_name, tc->name);
+    table = shash_node->data;
+
+    return shash_find(&table->outstanding_col_fetch_reqs,
+                      column->name) != NULL;
+}
+
+/* Return true if 'table' has a pending fetch operation.
+ *
+ * This function only considers on-demand requests done explicitly over 'table'
+ * i.e. after calling ovsdb_idl_fetch_table().
+ *
+ * It does not take into account columns nor rows requests.
+ */
+bool
+ovsdb_idl_is_table_fetch_pending(struct ovsdb_idl *idl,
+                                 const struct ovsdb_idl_table_class *tc) {
+    struct shash_node *shash_node;
+    struct ovsdb_idl_table *table;
+    shash_node = shash_find(&idl->table_by_name, tc->name);
+    table = shash_node->data;
+
+    return table->has_pending_fetch;
+}
+
+/* This function fetches the value of 'column' for the especified 'row'.
+ *
+ * After calling this function, the IDL requests the required value to the
+ * ovsdb server and updates it in the local replica.
+ *
+ * The function ovsdb_idl_is_row_fetch_pending can be used to verify if the
+ * fetch request has been processed.
+ */
+void
+ovsdb_idl_fetch_row(struct ovsdb_idl *idl,
+                    struct ovsdb_idl_row *row,
+                    const struct ovsdb_idl_column *column)
+{
+    struct json *request;
+    struct json *op;
+    struct json *columns;
+    struct json *fetch_id;
+    int status;
+    struct ovsdb_idl_fetch_node *fetch_node;
+
+    if (!(row->table->modes[column - row->table->class->columns] &
+          OVSDB_IDL_ON_DEMAND)) {
+        VLOG_WARN_RL(&syntax_rl,
+                "Error attempting to fetch a monitored column");
+        return;
+    }
+
+    request = json_array_create_1(
+            json_string_create(idl->class->database));
+    op = json_object_create();
+    json_object_put_string(op, "op", "select");
+    json_object_put_string(op, "table", row->table->class->name);
+    json_object_put(op, "where", where_uuid_equals(&row->uuid));
+    columns = json_array_create_2(json_string_create("_uuid"),
+                                  json_string_create(column->name));
+    json_object_put(op, "columns", columns);
+
+    json_array_add(request, op);
+    status = jsonrpc_session_send(idl->session,
+                jsonrpc_create_request("transact", request, &fetch_id));
+
+    if (status) {
+        VLOG_WARN_RL(&syntax_rl,
+                "Error while sending row fetch request (%d)", status);
+
+        json_destroy(fetch_id);
+        return;
+    }
+
+    fetch_node = xmalloc(sizeof *fetch_node);
+    shash_init(&fetch_node->columns);
+    shash_add_assert(&fetch_node->columns, column->name,
+                     CONST_CAST(struct ovsdb_idl_column *, column));
+
+    fetch_node->table = row->table;
+    fetch_node->fetch_type = OVSDB_IDL_ROW_FETCH;
+
+    hmap_insert(&idl->outstanding_fetch_reqs, &fetch_node->hmap_node,
+                json_hash(fetch_id, 0));
+
+    json_destroy(fetch_id);
+    row->outstanding_fetch_reqs++;
+}
+
+/* This function fetches the value 'column' for all the rows in the table.
+ *
+ * After calling this function, the IDL requests the required values to the
+ * ovsdb server and updates it in the local replica.
+ *
+ * The function ovsdb_idl_is_column_fetch_pending can be used to verify if the
+ * fetch request has been processed.
+ */
+void
+ovsdb_idl_fetch_column(struct ovsdb_idl *idl,
+                       const struct ovsdb_idl_table_class *table_class,
+                       struct ovsdb_idl_column *column)
+{
+    struct json *request;
+    struct json *op;
+    struct json *columns;
+    struct json *fetch_id;
+    int status;
+    struct ovsdb_idl_fetch_node *fetch_node;
+    struct ovsdb_idl_table *table;
+    struct shash_node *shash_node;
+
+    shash_node = shash_find(&idl->table_by_name, table_class->name);
+
+    if (!shash_node) {
+        VLOG_WARN_RL(&syntax_rl, "error attempting to fetch an unknown table");
+        return;
+    }
+
+    table = shash_node->data;
+
+    if (!(table->modes[column - table_class->columns] &
+          OVSDB_IDL_ON_DEMAND)) {
+        VLOG_WARN_RL(&syntax_rl,
+                "error attempting to fetch a monitored column");
+        return;
+    }
+
+    request = json_array_create_1(
+            json_string_create(idl->class->database));
+    op = json_object_create();
+    json_object_put_string(op, "op", "select");
+    json_object_put_string(op, "table", table_class->name);
+    json_object_put(op, "where", json_array_create_empty());
+    columns = json_array_create_2(json_string_create("_uuid"),
+                                  json_string_create(column->name));
+    json_object_put(op, "columns", columns);
+
+    json_array_add(request, op);
+    status = jsonrpc_session_send(idl->session,
+                jsonrpc_create_request("transact", request, &fetch_id));
+
+    if (status) {
+        VLOG_WARN_RL(&syntax_rl,
+                "Error while sending column fetch request (%d)", status);
+
+        json_destroy(fetch_id);
+        return;
+    }
+
+    fetch_node = xmalloc(sizeof *fetch_node);
+    shash_init(&fetch_node->columns);
+    shash_add_assert(&fetch_node->columns, column->name,
+                     CONST_CAST(struct ovsdb_idl_column *, column));
+    fetch_node->table = table;
+    fetch_node->fetch_type = OVSDB_IDL_COLUMN_FETCH;
+
+    hmap_insert(&idl->outstanding_fetch_reqs, &fetch_node->hmap_node,
+                json_hash(fetch_id, 0));
+
+    json_destroy(fetch_id);
+    shash_add(&table->outstanding_col_fetch_reqs, column->name, NULL);
+}
+
+/* This function fetches the value of all the on-demand columns in 'table'
+ *
+ * After calling this function, the IDL requests the required values to the
+ * ovsdb server and updates it in the local replica.
+ *
+ * The function ovsdb_idl_is_table_fetch_pending can be used to verify if the
+ * fetch request has been processed.
+ */
+void
+ovsdb_idl_fetch_table(struct ovsdb_idl *idl,
+                      struct ovsdb_idl_table_class *table_class)
+{
+    struct json *request;
+    struct json *op;
+    struct json *columns;
+    struct json *fetch_id;
+    int status;
+    struct ovsdb_idl_column *column;
+    struct ovsdb_idl_fetch_node *fetch_node;
+    struct ovsdb_idl_table *table;
+    struct shash_node *shash_node;
+
+    shash_node = shash_find(&idl->table_by_name, table_class->name);
+
+    if (!shash_node) {
+        VLOG_WARN_RL(&syntax_rl, "error attempting to fetch an unknown table");
+        return;
+    }
+
+    table = shash_node->data;
+
+    /* Create the fetch node and store the columns*/
+    fetch_node = xmalloc(sizeof *fetch_node);
+    shash_init(&fetch_node->columns);
+    fetch_node->table = table;
+    fetch_node->fetch_type = OVSDB_IDL_TABLE_FETCH;
+
+
+    request = json_array_create_1(json_string_create(idl->class->database));
+
+    op = json_object_create();
+    json_object_put_string(op, "op", "select");
+    json_object_put_string(op, "table", table->class->name);
+    json_object_put(op, "where", json_array_create_empty());
+
+    columns = json_array_create_1(json_string_create("_uuid"));
+
+    /* Add the on-demand columns to the request */
+    SHASH_FOR_EACH(shash_node, &table->columns) {
+        column = (struct ovsdb_idl_column*)shash_node->data;
+        if ((table->modes[column - table->class->columns] &
+                    OVSDB_IDL_ON_DEMAND)) {
+            json_array_add(columns, json_string_create(column->name));
+            shash_add(&fetch_node->columns, column->name, column);
+        }
+    }
+
+    json_object_put(op, "columns", columns);
+
+    json_array_add(request, op);
+    status = jsonrpc_session_send(idl->session,
+                 jsonrpc_create_request("transact", request, &fetch_id));
+
+    if (status) {
+        VLOG_WARN_RL(&syntax_rl,
+                     "Error while sending column fetch request (%d)", status);
+        json_destroy(fetch_id);
+        return;
+    }
+
+    hmap_insert(&idl->outstanding_fetch_reqs, &fetch_node->hmap_node,
+                json_hash(fetch_id, 0));
+
+    json_destroy(fetch_id);
+    table->has_pending_fetch = true;
+}
+
+
 /* Returns true if the field represented by 'column' in 'row' may be modified,
  * false if it is immutable.
  *
@@ -2464,8 +2927,9 @@ ovsdb_idl_txn_write__(const struct ovsdb_idl_row *row_,
 
     ovs_assert(row->new != NULL);
     ovs_assert(column_idx < class->n_columns);
-    ovs_assert(row->old == NULL ||
-               row->table->modes[column_idx] & OVSDB_IDL_MONITOR);
+    ovs_assert(row->old == NULL
+               || row->table->modes[column_idx] & OVSDB_IDL_MONITOR
+               || row->table->modes[column_idx] & OVSDB_IDL_ON_DEMAND);
 
     if (row->table->idl->verify_write_only && !write_only) {
         VLOG_ERR("Bug: Attempt to write to a read/write column (%s:%s) when"
diff --git a/lib/ovsdb-idl.h b/lib/ovsdb-idl.h
index 2b12e4d..a8be0f0 100644
--- a/lib/ovsdb-idl.h
+++ b/lib/ovsdb-idl.h
@@ -1,4 +1,5 @@
 /* Copyright (c) 2009, 2010, 2011, 2012, 2013, 2014, 2015 Nicira, Inc.
+ * Copyright (C) 2016 Hewlett Packard Enterprise Development LP
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -38,6 +39,7 @@
 #include <stdint.h>
 #include "compiler.h"
 #include "ovsdb-types.h"
+#include "skiplist.h"
 
 struct json;
 struct ovsdb_datum;
@@ -311,4 +313,65 @@ void ovsdb_idl_loop_destroy(struct ovsdb_idl_loop *);
 struct ovsdb_idl_txn *ovsdb_idl_loop_run(struct ovsdb_idl_loop *);
 void ovsdb_idl_loop_commit_and_wait(struct ovsdb_idl_loop *);
 
+struct ovsdb_idl_index *
+ovsdb_idl_create_index(struct ovsdb_idl *idl,
+                       const struct ovsdb_idl_table_class *tc,
+                       const char *index_name);
+
+#define OVSDB_INDEX_DESC -1
+#define OVSDB_INDEX_ASC 1
+
+/*
+ * Skiplist comparison function. Allows to store sorted data.
+ */
+typedef int
+(*column_comparator)(const void *a, const void *b);
+
+/*
+ * Defines a IDL compound index
+ */
+struct ovsdb_idl_index {
+    struct skiplist *skiplist;                  /* Skiplist with pointer to
+                                                 * rows*/
+    const struct ovsdb_idl_column **columns;    /* Columns indexed */
+    column_comparator *comparers;               /* Compare functions used */
+    int *sorting_order;                         /* Order per column */
+    size_t n_columns;                           /* Number of columns in index */
+    size_t alloc_columns;                       /* Size allocated memory for
+                                                 * columns, comparers and
+                                                 * sorting order */
+    bool row_sync;                              /* Determines if the replica
+                                                 * is modifying its content or
+                                                 * not */
+    const struct ovsdb_idl_table *table;        /* Table that owns this index */
+    const char* index_name;                     /* The name of this index */
+};
+
+struct ovsdb_idl_index_cursor {
+    struct ovsdb_idl_index *index;    /* Index used by this cursor */
+    struct skiplist_node *position;   /* Current position in the index */
+};
+
+int ovsdb_idl_index_strcmp(char *, char *);
+int ovsdb_idl_index_intcmp(int64_t, int64_t);
+int ovsdb_idl_index_doublecmp(double, double);
+void ovsdb_idl_index_add_column(struct ovsdb_idl_index *,
+                           const struct ovsdb_idl_column *,
+                           int order,
+                           column_comparator custom_comparer
+                           );
+bool ovsdb_idl_initialize_cursor(struct ovsdb_idl *,
+                            const struct ovsdb_idl_table_class *tc,
+                            const char *index_name,
+                            struct ovsdb_idl_index_cursor *cursor);
+struct ovsdb_idl_row *ovsdb_idl_index_first(struct ovsdb_idl_index_cursor *);
+struct ovsdb_idl_row *ovsdb_idl_index_next(struct ovsdb_idl_index_cursor *);
+struct ovsdb_idl_row *ovsdb_idl_index_data(struct ovsdb_idl_index_cursor *);
+struct ovsdb_idl_row *ovsdb_idl_index_find(struct ovsdb_idl_index_cursor *,
+                                           struct ovsdb_idl_row *);
+struct ovsdb_idl_row *ovsdb_idl_index_forward_to(struct ovsdb_idl_index_cursor *,
+                                           struct ovsdb_idl_row *);
+int ovsdb_idl_index_compare(struct ovsdb_idl_index_cursor *,
+                            struct ovsdb_idl_row *a, struct ovsdb_idl_row *b);
+
 #endif /* ovsdb-idl.h */
diff --git a/lib/ovsdb-idl.h.orig b/lib/ovsdb-idl.h.orig
new file mode 100644
index 0000000..2b12e4d
--- /dev/null
+++ b/lib/ovsdb-idl.h.orig
@@ -0,0 +1,314 @@
+/* Copyright (c) 2009, 2010, 2011, 2012, 2013, 2014, 2015 Nicira, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OVSDB_IDL_H
+#define OVSDB_IDL_H 1
+
+/* Open vSwitch Database Interface Definition Language (OVSDB IDL).
+ *
+ * The OVSDB IDL maintains an in-memory replica of a database.  It issues RPC
+ * requests to an OVSDB database server and parses the responses, converting
+ * raw JSON into data structures that are easier for clients to digest.  Most
+ * notably, references to rows via UUID become C pointers.
+ *
+ * The IDL always presents a consistent snapshot of the database to its client,
+ * that is, it won't present the effects of some part of a transaction applied
+ * at the database server without presenting all of its effects.
+ *
+ * The IDL also assists with issuing database transactions.  The client creates
+ * a transaction, manipulates the IDL data structures, and commits or aborts
+ * the transaction.  The IDL then composes and issues the necessary JSON-RPC
+ * requests and reports to the client whether the transaction completed
+ * successfully.
+ */
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "compiler.h"
+#include "ovsdb-types.h"
+
+struct json;
+struct ovsdb_datum;
+struct ovsdb_idl_class;
+struct ovsdb_idl_row;
+struct ovsdb_idl_column;
+struct ovsdb_idl_table;
+struct ovsdb_idl_table_class;
+struct uuid;
+
+struct ovsdb_idl *ovsdb_idl_create(const char *remote,
+                                   const struct ovsdb_idl_class *,
+                                   bool monitor_everything_by_default,
+                                   bool retry);
+void ovsdb_idl_destroy(struct ovsdb_idl *);
+
+void ovsdb_idl_run(struct ovsdb_idl *);
+void ovsdb_idl_wait(struct ovsdb_idl *);
+
+void ovsdb_idl_set_lock(struct ovsdb_idl *, const char *lock_name);
+bool ovsdb_idl_has_lock(const struct ovsdb_idl *);
+bool ovsdb_idl_is_lock_contended(const struct ovsdb_idl *);
+
+unsigned int ovsdb_idl_get_seqno(const struct ovsdb_idl *);
+bool ovsdb_idl_has_ever_connected(const struct ovsdb_idl *);
+void ovsdb_idl_enable_reconnect(struct ovsdb_idl *);
+void ovsdb_idl_force_reconnect(struct ovsdb_idl *);
+void ovsdb_idl_verify_write_only(struct ovsdb_idl *);
+
+bool ovsdb_idl_is_alive(const struct ovsdb_idl *);
+int ovsdb_idl_get_last_error(const struct ovsdb_idl *);
+
+/* Choosing columns and tables to replicate. */
+
+/* Modes with which the IDL can monitor a column.
+ *
+ * If no bits are set, the column is not monitored at all.  Its value will
+ * always appear to the client to be the default value for its type.
+ *
+ * If OVSDB_IDL_MONITOR is set, then the column is replicated.  Its value will
+ * reflect the value in the database.  If OVSDB_IDL_ALERT is also set, then the
+ * value returned by ovsdb_idl_get_seqno() will change when the column's value
+ * changes.
+ *
+ * The possible mode combinations are:
+ *
+ *   - 0, for a column that a client doesn't care about.
+ *
+ *   - (OVSDB_IDL_MONITOR | OVSDB_IDL_ALERT), for a column that a client wants
+ *     to track and possibly update.
+ *
+ *   - OVSDB_IDL_MONITOR, for columns that a client treats as "write-only",
+ *     that is, it updates them but doesn't want to get alerted about its own
+ *     updates.  It also won't be alerted about other clients' updates, so this
+ *     is suitable only for use by a client that "owns" a particular column.
+ *
+ *   - OVDSB_IDL_ALERT without OVSDB_IDL_MONITOR is not valid.
+ *
+ *   - (OVSDB_IDL_MONITOR | OVSDB_IDL_ALERT | OVSDB_IDL_TRACK), for a column
+ *     that a client wants to track using the change tracking
+ *     ovsdb_idl_track_get_*() functions.
+ */
+#define OVSDB_IDL_MONITOR (1 << 0) /* Monitor this column? */
+#define OVSDB_IDL_ALERT   (1 << 1) /* Alert client when column updated? */
+#define OVSDB_IDL_TRACK   (1 << 2)
+#define OVSDB_IDL_ON_DEMAND (1 << 3) /* Manually update columns */
+
+/* On-demand fetch columns.
+ * Fetch request types.
+ */
+enum ovsdb_idl_fetch_type {
+    OVSDB_IDL_ROW_FETCH,    /* Fetch a column value for a given row. */
+    OVSDB_IDL_COLUMN_FETCH, /* Fetch the value of a whole column. */
+    OVSDB_IDL_TABLE_FETCH   /* Fetch the value of all on-demand
+                               columns that are part of given table. */
+};
+
+void ovsdb_idl_add_column(struct ovsdb_idl *, const struct ovsdb_idl_column *);
+void ovsdb_idl_add_on_demand_column(struct ovsdb_idl *,
+                                    struct ovsdb_idl_table_class *,
+                                    const struct ovsdb_idl_column *);
+void ovsdb_idl_add_table(struct ovsdb_idl *,
+                         const struct ovsdb_idl_table_class *);
+
+void ovsdb_idl_omit(struct ovsdb_idl *, const struct ovsdb_idl_column *);
+void ovsdb_idl_omit_alert(struct ovsdb_idl *, const struct ovsdb_idl_column *);
+
+/* Change tracking. */
+enum ovsdb_idl_change {
+    OVSDB_IDL_CHANGE_INSERT,
+    OVSDB_IDL_CHANGE_MODIFY,
+    OVSDB_IDL_CHANGE_DELETE,
+    OVSDB_IDL_CHANGE_MAX
+};
+
+/* Row, table sequence numbers */
+unsigned int ovsdb_idl_table_get_seqno(
+    const struct ovsdb_idl *idl,
+    const struct ovsdb_idl_table_class *table_class);
+unsigned int ovsdb_idl_row_get_seqno(
+    const struct ovsdb_idl_row *row,
+    enum ovsdb_idl_change change);
+
+void ovsdb_idl_track_add_column(struct ovsdb_idl *idl,
+                                const struct ovsdb_idl_column *column);
+void ovsdb_idl_track_add_all(struct ovsdb_idl *idl);
+const struct ovsdb_idl_row *ovsdb_idl_track_get_first(
+    const struct ovsdb_idl *, const struct ovsdb_idl_table_class *);
+const struct ovsdb_idl_row *ovsdb_idl_track_get_next(const struct ovsdb_idl_row *);
+void ovsdb_idl_track_clear(const struct ovsdb_idl *);
+
+
+/* Reading the database replica. */
+
+const struct ovsdb_idl_row *ovsdb_idl_get_row_for_uuid(
+    const struct ovsdb_idl *, const struct ovsdb_idl_table_class *,
+    const struct uuid *);
+const struct ovsdb_idl_row *ovsdb_idl_first_row(
+    const struct ovsdb_idl *, const struct ovsdb_idl_table_class *);
+const struct ovsdb_idl_row *ovsdb_idl_next_row(const struct ovsdb_idl_row *);
+
+const struct ovsdb_datum *ovsdb_idl_read(const struct ovsdb_idl_row *,
+                                         const struct ovsdb_idl_column *);
+const struct ovsdb_datum *ovsdb_idl_get(const struct ovsdb_idl_row *,
+                                        const struct ovsdb_idl_column *,
+                                        enum ovsdb_atomic_type key_type,
+                                        enum ovsdb_atomic_type value_type);
+void ovsdb_idl_fetch_row(struct ovsdb_idl *,
+                         struct ovsdb_idl_row *,
+                         const struct ovsdb_idl_column *);
+void ovsdb_idl_fetch_column(struct ovsdb_idl *,
+                            const struct ovsdb_idl_table_class *,
+                            struct ovsdb_idl_column *);
+void ovsdb_idl_fetch_table(struct ovsdb_idl *,
+                           struct ovsdb_idl_table_class *);
+
+bool ovsdb_idl_is_row_fetch_pending(const struct ovsdb_idl_row *);
+bool ovsdb_idl_is_column_fetch_pending(struct ovsdb_idl *,
+                                       const struct ovsdb_idl_table_class *,
+                                       const struct ovsdb_idl_column *);
+bool ovsdb_idl_is_table_fetch_pending(struct ovsdb_idl *,
+                                      const struct ovsdb_idl_table_class *);
+
+bool ovsdb_idl_is_mutable(const struct ovsdb_idl_row *,
+                          const struct ovsdb_idl_column *);
+
+bool ovsdb_idl_row_is_synthetic(const struct ovsdb_idl_row *);
+
+/* Transactions.
+ *
+ * A transaction may modify the contents of a database by modifying the values
+ * of columns, deleting rows, inserting rows, or adding checks that columns in
+ * the database have not changed ("verify" operations), through
+ * ovsdb_idl_txn_*() functions.  (The OVSDB IDL code generator produces helper
+ * functions that internally call the ovsdb_idl_txn_*() functions.  These are
+ * likely to be more convenient.)
+ *
+ * Reading and writing columns and inserting and deleting rows are all
+ * straightforward.  The reasons to verify columns are less obvious.
+ * Verification is the key to maintaining transactional integrity.  Because
+ * OVSDB handles multiple clients, it can happen that between the time that
+ * OVSDB client A reads a column and writes a new value, OVSDB client B has
+ * written that column.  Client A's write should not ordinarily overwrite
+ * client B's, especially if the column in question is a "map" column that
+ * contains several more or less independent data items.  If client A adds a
+ * "verify" operation before it writes the column, then the transaction fails
+ * in case client B modifies it first.  Client A will then see the new value of
+ * the column and compose a new transaction based on the new contents written
+ * by client B.
+ *
+ * When a transaction is complete, which must be before the next call to
+ * ovsdb_idl_run() on 'idl', call ovsdb_idl_txn_commit() or
+ * ovsdb_idl_txn_abort().
+ *
+ * The life-cycle of a transaction looks like this:
+ *
+ * 1. Create the transaction and record the initial sequence number:
+ *
+ *     seqno = ovsdb_idl_get_seqno(idl);
+ *     txn = ovsdb_idl_txn_create(idl);
+ *
+ * 2. Modify the database with ovsdb_idl_txn_*() functions directly or
+ *    indirectly.
+ *
+ * 3. Commit the transaction by calling ovsdb_idl_txn_commit().  The first call
+ *    to this function probably returns TXN_INCOMPLETE.  The client must keep
+ *    calling again along as this remains true, calling ovsdb_idl_run() in
+ *    between to let the IDL do protocol processing.  (If the client doesn't
+ *    have anything else to do in the meantime, it can use
+ *    ovsdb_idl_txn_commit_block() to avoid having to loop itself.)
+ *
+ * 4. If the final status is TXN_TRY_AGAIN, wait for ovsdb_idl_get_seqno() to
+ *    change from the saved 'seqno' (it's possible that it's already changed,
+ *    in which case the client should not wait at all), then start over from
+ *    step 1.  Only a call to ovsdb_idl_run() will change the return value of
+ *    ovsdb_idl_get_seqno().  (ovsdb_idl_txn_commit_block() calls
+ *    ovsdb_idl_run().)
+ */
+
+enum ovsdb_idl_txn_status {
+    TXN_UNCOMMITTED,            /* Not yet committed or aborted. */
+    TXN_UNCHANGED,              /* Transaction didn't include any changes. */
+    TXN_INCOMPLETE,             /* Commit in progress, please wait. */
+    TXN_ABORTED,                /* ovsdb_idl_txn_abort() called. */
+    TXN_SUCCESS,                /* Commit successful. */
+    TXN_TRY_AGAIN,              /* Commit failed because a "verify" operation
+                                 * reported an inconsistency, due to a network
+                                 * problem, or other transient failure.  Wait
+                                 * for a change, then try again. */
+    TXN_NOT_LOCKED,             /* Server hasn't given us the lock yet. */
+    TXN_ERROR                   /* Commit failed due to a hard error. */
+};
+
+const char *ovsdb_idl_txn_status_to_string(enum ovsdb_idl_txn_status);
+
+struct ovsdb_idl_txn *ovsdb_idl_txn_create(struct ovsdb_idl *);
+void ovsdb_idl_txn_add_comment(struct ovsdb_idl_txn *, const char *, ...)
+    OVS_PRINTF_FORMAT (2, 3);
+void ovsdb_idl_txn_set_dry_run(struct ovsdb_idl_txn *);
+void ovsdb_idl_txn_increment(struct ovsdb_idl_txn *,
+                             const struct ovsdb_idl_row *,
+                             const struct ovsdb_idl_column *);
+void ovsdb_idl_txn_destroy(struct ovsdb_idl_txn *);
+void ovsdb_idl_txn_wait(const struct ovsdb_idl_txn *);
+enum ovsdb_idl_txn_status ovsdb_idl_txn_commit(struct ovsdb_idl_txn *);
+enum ovsdb_idl_txn_status ovsdb_idl_txn_commit_block(struct ovsdb_idl_txn *);
+void ovsdb_idl_txn_abort(struct ovsdb_idl_txn *);
+
+const char *ovsdb_idl_txn_get_error(const struct ovsdb_idl_txn *);
+
+int64_t ovsdb_idl_txn_get_increment_new_value(const struct ovsdb_idl_txn *);
+const struct uuid *ovsdb_idl_txn_get_insert_uuid(const struct ovsdb_idl_txn *,
+                                                 const struct uuid *);
+
+void ovsdb_idl_txn_write(const struct ovsdb_idl_row *,
+                         const struct ovsdb_idl_column *,
+                         struct ovsdb_datum *);
+void ovsdb_idl_txn_write_clone(const struct ovsdb_idl_row *,
+                               const struct ovsdb_idl_column *,
+                               const struct ovsdb_datum *);
+void ovsdb_idl_txn_write_partial_map(const struct ovsdb_idl_row *,
+                                const struct ovsdb_idl_column *,
+                                struct ovsdb_datum *);
+void ovsdb_idl_txn_delete_partial_map(const struct ovsdb_idl_row *,
+                                const struct ovsdb_idl_column *,
+                                struct ovsdb_datum *);
+void ovsdb_idl_txn_delete(const struct ovsdb_idl_row *);
+const struct ovsdb_idl_row *ovsdb_idl_txn_insert(
+    struct ovsdb_idl_txn *, const struct ovsdb_idl_table_class *,
+    const struct uuid *);
+
+struct ovsdb_idl *ovsdb_idl_txn_get_idl (struct ovsdb_idl_txn *);
+void ovsdb_idl_get_initial_snapshot(struct ovsdb_idl *);
+
+
+/* ovsdb_idl_loop provides an easy way to manage the transactions related
+ * to 'idl' and to cope with different status during transaction. */
+struct ovsdb_idl_loop {
+    struct ovsdb_idl *idl;
+    unsigned int skip_seqno;
+
+    struct ovsdb_idl_txn *committing_txn;
+    unsigned int precommit_seqno;
+
+    struct ovsdb_idl_txn *open_txn;
+};
+
+#define OVSDB_IDL_LOOP_INITIALIZER(IDL) { .idl = (IDL) }
+
+void ovsdb_idl_loop_destroy(struct ovsdb_idl_loop *);
+struct ovsdb_idl_txn *ovsdb_idl_loop_run(struct ovsdb_idl_loop *);
+void ovsdb_idl_loop_commit_and_wait(struct ovsdb_idl_loop *);
+
+#endif /* ovsdb-idl.h */
diff --git a/lib/skiplist.c b/lib/skiplist.c
new file mode 100644
index 0000000..01e296c
--- /dev/null
+++ b/lib/skiplist.c
@@ -0,0 +1,292 @@
+/* Copyright (C) 2016 Hewlett Packard Enterprise Development LP
+ * All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License. You may obtain
+ * a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+/*
+ * Skiplist implementationn based on:
+ * "Skip List: A Probabilistic Alternative to Balanced Trees",
+ * by William Pugh.
+ */
+
+#include <config.h>
+#include <stdio.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "skiplist.h"
+#include "random.h"
+
+#define SKIPLIST_MAX_LEVELS 64
+
+/*
+ * Skiplist node container
+ */
+struct skiplist_node
+{
+    const void* data;                       /* Pointer to saved data */
+    uint64_t height;                        /* Height of this node */
+    struct skiplist_node *forward[];        /* Links to the next nodes */
+};
+
+/*
+ * Skiplist container
+ */
+
+struct skiplist
+{
+    struct skiplist_node *header;   /* Pointer to head node
+                                       (not first data node)*/
+    skiplist_comparator cmp;        /* Pointer to the skiplist's comparison
+                                       function*/
+    void *cfg;                      /* Pointer to optional comparison
+                                       configuration, used by the comparator */
+    int max_levels;                 /* Max levels of the skiplist. */
+    uint64_t probability;           /* Probability that the node would take an
+                                       additional skiplist level. */
+    int64_t size;                   /* Current size of the skiplist. */
+    int64_t level;                  /* Max number of levels used in this
+                                       skiplist*/
+    void (*free_func)(void *);      /* Function that free the value's memory */
+};
+
+static int skiplist_determine_level(struct skiplist* sl);
+
+static struct skiplist_node* skiplist_create_node(int, const void *);
+
+static struct skiplist_node*
+skiplist_forward_to_(struct skiplist* sl, const void *value,
+                     struct skiplist_node **update);
+
+/*
+ * skiplist_create returns a new skiplist, configured with given max_levels,
+ * data comparer and configuration.
+ * Sets a probability of 0.5 (RAND_MAX / 2).
+ */
+struct skiplist*
+skiplist_create(int max_levels, skiplist_comparator object_comparator,
+                void *configuration)
+{
+    random_init();
+    struct skiplist *sl;
+    sl = malloc(sizeof(struct skiplist));
+    sl->cfg = configuration;
+    sl->max_levels = max_levels < SKIPLIST_MAX_LEVELS ?
+            max_levels : SKIPLIST_MAX_LEVELS;
+    sl->size = 0;
+    sl->level = 0;
+    sl->cmp = object_comparator;
+    sl->probability = UINT32_MAX / 2;
+    sl->header = skiplist_create_node(sl->max_levels, NULL);
+    sl->free_func = NULL;
+
+    return sl;
+}
+
+/*
+ * Set a custom function that free the value's memory when
+ * destroying the skiplist.
+ */
+void
+skiplist_set_free_func(struct skiplist* sl, void (*func)(void *))
+{
+    sl->free_func = func;
+}
+
+/*
+ * Determines the correspondent level for a skiplist node.
+ */
+static int
+skiplist_determine_level(struct skiplist* sl)
+{
+    int lvl = 0;
+    while(random_uint32() <= sl->probability && lvl < sl->max_levels){
+        lvl++;
+    }
+    return lvl;
+}
+
+/*
+ * Creates a new skiplist_node with given levels and data.
+ */
+static struct skiplist_node*
+skiplist_create_node(int levels, const void *object)
+{
+    struct skiplist_node *new_node = malloc(sizeof(struct skiplist_node) +
+                                  (levels+1) * sizeof(struct skiplist_node *));
+    new_node->data = object;
+    new_node->height = levels;
+    memset(new_node->forward, 0, (levels+1) * sizeof(struct skiplist_node *));
+    return new_node;
+}
+
+/*
+ * Find the first exact match of value in the skiplist
+ */
+struct skiplist_node*
+skiplist_find(struct skiplist* sl, const void *value)
+{
+    struct skiplist_node *x = skiplist_forward_to(sl, value);
+    return x && sl->cmp(x->data, value, sl->cfg) == 0 ? x : NULL;
+}
+
+/*
+ * Moves the cursor forward, to the first data equal or greater than value.
+ */
+struct skiplist_node*
+skiplist_forward_to(struct skiplist* sl, const void *value)
+{
+    return skiplist_forward_to_(sl, value, NULL);
+}
+
+static struct skiplist_node*
+skiplist_forward_to_(struct skiplist* sl, const void *value,
+                     struct skiplist_node **update)
+{
+    struct skiplist_node *x = sl->header;
+    int i;
+
+    /* Loop invariant: x < value */
+    for(i = sl->level; i >= 0; i--){
+        while(x->forward[i] &&
+                sl->cmp(x->forward[i]->data, value, sl->cfg) < 0){
+            x = x->forward[i];
+        }
+        /* x < value <= x->forward[1]*/
+        if(update){
+            update[i] = x;
+        }
+    }
+    /* x < value <= x->forward[1]*/
+    x = x->forward[0];
+    return x;
+}
+
+/*
+ * Inserts data into skiplist.
+ */
+void
+skiplist_insert(struct skiplist* list, const void *value)
+{
+    struct skiplist_node *update[SKIPLIST_MAX_LEVELS+1] = {NULL};
+    int i, lvl;
+    struct skiplist_node *x = skiplist_forward_to_(list, value, update);
+
+    if(x && list->cmp(x->data, value, list->cfg) == 0) {
+        x->data = value;
+    } else {
+        lvl = skiplist_determine_level(list);
+        if(lvl > list->level){
+            for(i = list->level + 1; i <= lvl; i++){
+                update[i] = list->header;
+            }
+            list->level = lvl;
+        }
+        x = skiplist_create_node(lvl, value);
+        for(i = 0; i <= lvl; i++){
+            x->forward[i] = update[i]->forward[i];
+            update[i]->forward[i] = x;
+        }
+        list->size++;
+    }
+}
+
+/*
+ * Removes first ocurrence of data from skiplist.
+ */
+void *
+skiplist_delete(struct skiplist* list, const void *value)
+{
+    struct skiplist_node *update[SKIPLIST_MAX_LEVELS+1] = {NULL};
+    void *data = NULL;
+    int i;
+    struct skiplist_node *x = list->header;
+    x = skiplist_forward_to_(list, value, update);
+
+    if(x && list->cmp(x->data, value, list->cfg) == 0) {
+        for(i = 0; i <= list->level; i++){
+            if(!update[i]->forward[i] ||
+                    list->cmp(update[i]->forward[i]->data, value, list->cfg) != 0){
+                break;
+            }
+            update[i]->forward[i] = x->forward[i];
+        }
+        data = (void *) x->data;
+        free(x);
+
+        while(list->level > 0 && !list->header->forward[list->level]){
+            list->level--;
+        }
+        list->size--;
+    }
+    return data;
+}
+
+/*
+ * Returns the value stored in the skiplist node
+ */
+void *
+skiplist_get_data(struct skiplist_node *node)
+{
+    return node ? (void *) node->data : NULL;
+}
+
+/*
+ * Returns the count of items in the skiplist
+ */
+int64_t
+skiplist_get_size(struct skiplist* sl)
+{
+    return sl->size;
+}
+
+/*
+ * Returns the first element in the skiplist
+ */
+struct skiplist_node *
+skiplist_first(struct skiplist* sl)
+{
+    return sl->header->forward[0];
+}
+
+/*
+ * Given a skiplist node, returns a pointer to the next skiplist node.
+ */
+struct skiplist_node *
+skiplist_next(struct skiplist_node* node)
+{
+    return node ? node->forward[0] : NULL;
+}
+
+/*
+ * Destroys the skiplist, and frees all the skiplist nodes, but NOT the data
+ * stored.
+ */
+void
+skiplist_destroy(struct skiplist* sl)
+{
+    struct skiplist_node *node, *next;
+    next = node = sl->header;
+    while(next != NULL){
+        next = node->forward[0];
+        if(sl->free_func) {
+            sl->free_func((void *)node->data);
+        }
+        free(node);
+        node = next;
+    }
+    free(sl);
+}
diff --git a/lib/skiplist.h b/lib/skiplist.h
new file mode 100644
index 0000000..23e7e93
--- /dev/null
+++ b/lib/skiplist.h
@@ -0,0 +1,53 @@
+/* Copyright (C) 2016 Hewlett Packard Enterprise Development LP
+ * All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License. You may obtain
+ * a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+#ifndef LIB_SKIPLIST_H_
+#define LIB_SKIPLIST_H_
+
+#include<stdbool.h>
+#include<stdint.h>
+#include<stdlib.h>
+
+/*
+ * Skiplist comparison function. Allows to store sorted data.
+ */
+typedef int
+(*skiplist_comparator)(const void *a, const void *b, const void* conf);
+
+struct skiplist_node;
+
+struct skiplist;
+
+#define SKIPLIST_FOR_EACH(SKIPLIST_NODE, SKIPLIST) \
+    for(SKIPLIST_NODE = skiplist_first(SKIPLIST); \
+        SKIPLIST_NODE; \
+        SKIPLIST_NODE = skiplist_next(SKIPLIST_NODE))
+
+struct skiplist* skiplist_create(int max_levels,
+                                 skiplist_comparator object_comparator,
+                                 void * configuration);
+void skiplist_set_free_func(struct skiplist* sl, void (*func)(void *));
+void skiplist_insert(struct skiplist* sl, const void *object);
+void *skiplist_delete(struct skiplist* sl, const void *object);
+struct skiplist_node* skiplist_find(struct skiplist* sl, const void *value);
+void * skiplist_get_data(struct skiplist_node *node);
+int64_t skiplist_get_size(struct skiplist* sl);
+struct skiplist_node* skiplist_forward_to(struct skiplist* sl, const void *value);
+struct skiplist_node * skiplist_first(struct skiplist* sl);
+struct skiplist_node * skiplist_next(struct skiplist_node* node);
+void skiplist_destroy(struct skiplist* sl);
+
+#endif /* LIB_SKIPLIST_H_ */
diff --git a/ovsdb/ovsdb-idlc.in b/ovsdb/ovsdb-idlc.in
index 828f596..36c5507 100755
--- a/ovsdb/ovsdb-idlc.in
+++ b/ovsdb/ovsdb-idlc.in
@@ -8,9 +8,15 @@ import sys
 import ovs.json
 import ovs.db.error
 import ovs.db.schema
+from ovs.db.types import StringType, IntegerType, RealType
 
 argv0 = sys.argv[0]
 
+def isColumnIndexable(column):
+    return not column.type.is_map()  and column.type.key.is_valid() \
+               and (column.type.is_scalar())  and \
+                column.type.key.toAtomicType() in ['OVSDB_TYPE_STRING', 'OVSDB_TYPE_REAL', 'OVSDB_TYPE_INTEGER']
+
 def parseSchema(filename):
     return ovs.db.schema.IdlSchema.from_json(ovs.json.from_file(filename))
 
@@ -240,6 +246,25 @@ const struct %(s)s *%(s)s_track_get_next(const struct %(s)s *);
              (ROW); \\
              (ROW) = %(s)s_track_get_next(ROW))
 
+int %(s)s_index_compare(struct ovsdb_idl_index_cursor *, const struct %(s)s *, const struct %(s)s *);
+const struct %(s)s *%(s)s_index_first(struct ovsdb_idl_index_cursor *);
+const struct %(s)s *%(s)s_index_next(struct ovsdb_idl_index_cursor *);
+const struct %(s)s *%(s)s_index_find(struct ovsdb_idl_index_cursor *, const struct %(s)s *);
+const struct %(s)s *%(s)s_index_forward_to(struct ovsdb_idl_index_cursor *, const struct %(s)s *);
+const struct %(s)s *%(s)s_index_get_data(const struct ovsdb_idl_index_cursor *);
+#define %(S)s_FOR_EACH_RANGE(ROW, CURSOR, FROM, TO) \\
+        for ((ROW) = %(s)s_index_forward_to(CURSOR, FROM); \\
+             ((ROW) && %(s)s_index_compare(CURSOR, ROW, TO) <= 0); \\
+             (ROW) = %(s)s_index_next(CURSOR))
+#define %(S)s_FOR_EACH_EQUAL(ROW, CURSOR, KEY) \\
+        for ((ROW) = %(s)s_index_find(CURSOR, KEY); \\
+             ((ROW) && %(s)s_index_compare(CURSOR, ROW, KEY) == 0); \\
+             (ROW) = %(s)s_index_next(CURSOR))
+#define %(S)s_FOR_EACH_BYINDEX(ROW, CURSOR) \\
+        for ((ROW) = %(s)s_index_first(CURSOR); \\
+             (ROW); \\
+             (ROW) = %(s)s_index_next(CURSOR))
+
 void %(s)s_init(struct %(s)s *);
 void %(s)s_delete(const struct %(s)s *);
 struct %(s)s *%(s)s_insert(struct ovsdb_idl_txn *);
@@ -321,6 +346,11 @@ struct %(s)s *%(s)s_insert(struct ovsdb_idl_txn *);
                 print '%(coltype)s);' % {'coltype':column.type.key.toCType(prefix)}
         print
 
+        for columnName, column in sorted(table.columns.iteritems()):
+            if isColumnIndexable(column):
+                print 'int %(s)s_index_%(c)s_cmp(const void *, const void *);' % {'s': structName, 'c': columnName}
+        print
+
     # Table indexes.
     printEnum("%stable_id" % prefix.lower(), ["%sTABLE_%s" % (prefix.upper(), tableName.upper()) for tableName in sorted(schema.tables)] + ["%sN_TABLES" % prefix.upper()])
     print
@@ -998,6 +1028,90 @@ void
         'C': columnName.upper()}
         # End Update/Delete of partial maps
 
+        # Column Index compare functions
+        for columnName, column in sorted(table.columns.iteritems()):
+            type = column.type
+            funcDict = {'OVSDB_TYPE_STRING': 'str', 'OVSDB_TYPE_REAL': 'double', 'OVSDB_TYPE_INTEGER': 'int'}
+            if isColumnIndexable(column):
+                print '''
+/*  Call an internal function defined to compare  "%(f)s" type columns for "%(c)s" columns
+    in "%(s)s" tables.
+    Parameters: void *row1, void * row2. Data to be compared. Must be of type corresponding the record of
+    the table.
+    Return value: 0 if both data values are equal, -1 if first parameter is less than second and 1 otherwise.
+    For internal use only. Not recomended to be called directly. */ ''' % {'s' : structName, 'c' : columnName, 'f': type.key.toAtomicType()}
+                print 'int'
+                print '%(s)s_index_%(c)s_cmp(const void *row1, const void *row2)' % \
+                    {'s': structName, 'c': columnName}
+                print '{'
+                print '    struct %(s)s *data1 = (struct %(s)s *)row1;' % { 's' : structName }
+                print '    struct %(s)s *data2 = (struct %(s)s *)row2;' % { 's' : structName }
+                print '    return ovsdb_idl_index_%(f)scmp(data1->%(c)s, data2->%(c)s);' % \
+                    {'c': columnName, 'f': funcDict[type.key.toAtomicType()] }
+                print "}"
+
+# Index table related functions
+        print '''
+/*  This function is used to compare "%(s)s" records on table in iterartion loops for compound-index operations.
+    After been called, cursor point to current position in the index
+    Parameters: struct ovsdb_idl_index_cursor *cursor. Cursor used to iterate over the indexed data on this table.
+                const struct "%(s)s" *const_data1,  const struct "%(s)s" *const_data2. Data to be compared.
+    Return value: 0 if both data values are equal, -1 if first parameter is less than second and 1 otherwise. */''' % {'s' : structName}
+        print 'int'
+        print '''%(s)s_index_compare(struct ovsdb_idl_index_cursor *cursor, const struct %(s)s *const_data1,  const struct %(s)s *const_data2)
+{
+    struct %(s)s *data1 = CONST_CAST(struct %(s)s *, const_data1);
+    struct %(s)s *data2 = CONST_CAST(struct %(s)s *, const_data2);
+    return ovsdb_idl_index_compare(cursor, &data1->header_, &data2->header_);
+}''' % { 's' : structName }
+        print '''
+/*  This function is called to position the cursor at the first row in "%(s)s" table on the associated compound-index.
+    Parameters: struct ovsdb_idl_index_cursor *cursor. Cursor used to iterate over the indexed data on this table.
+    Return value: The first row in the corresponding index. */''' %  {'s' : structName }
+        print '''const struct %(s)s *\n%(s)s_index_first(struct ovsdb_idl_index_cursor *cursor)
+{
+    return %(s)s_cast(ovsdb_idl_index_first(cursor));
+}''' % { 's' : structName }
+        print '''
+/*  This function is called to position the cursor at the next row in "%(s)s" table on the associated compound-index.
+    Parameters: struct ovsdb_idl_index_cursor *cursor. Cursor used to iterate over the indexed data on this table.
+    Return value: The next row in the corresponding index. */''' %  {'s' : structName, 'c' : columnName }
+        print '''const struct %(s)s *\n%(s)s_index_next(struct ovsdb_idl_index_cursor *cursor)
+{
+    return %(s)s_cast(ovsdb_idl_index_next(cursor));
+}''' % { 's' : structName }
+        print '''
+/*  This function is used to find the data of the row in "%(s)s" table that meet criteria with the requested data
+    associated in the compound-index.
+    Parameters: struct ovsdb_idl_index_cursor *cursor. Cursor used to iterate over the indexed data on this table.
+                const struct %(s)s *const_data. Data to be searched.
+    Return value: The row in the corresponding index if found or NULL otherwise. */''' %  {'s' : structName }
+        print '''const struct %(s)s *\n%(s)s_index_find(struct ovsdb_idl_index_cursor *cursor, const struct %(s)s *const_data)
+{
+    struct %(s)s *data = CONST_CAST(struct %(s)s *, const_data);
+    return %(s)s_cast(ovsdb_idl_index_find(cursor, &data->header_));
+}''' % { 's' : structName }
+        print '''
+/*  This function is used to set the cursor pointing to the row in "%(s)s" table that meet criteria of the requested data
+    associated in the compound-index.
+    Parameters: struct ovsdb_idl_index_cursor *cursor. Cursor used to iterate over the indexed data on this table.
+                const struct %(s)s *const_data. Data to be searched.
+    Return value: The row in the corresponding index closest to the criteria. */''' %  {'s' : structName }
+        print '''const struct %(s)s *\n%(s)s_index_forward_to(struct ovsdb_idl_index_cursor *cursor, const struct %(s)s *const_data)
+{
+    struct %(s)s *data = CONST_CAST(struct %(s)s *, const_data);
+    return %(s)s_cast(ovsdb_idl_index_forward_to(cursor, &data->header_));
+}''' % { 's' : structName }
+        print '''
+/*  This function is used to get the data of the row in the current position pointed by the cursor in
+    "%(s)s" table.
+    Parameters: struct ovsdb_idl_index_cursor *cursor. Cursor used to iterate over the indexed data on this table.
+    Return value: The row in the corresponding index if found or NULL otherwise. */''' %  {'s' : structName, 'c' : columnName }
+        print '''const struct %(s)s *\n%(s)s_index_get_data(const struct ovsdb_idl_index_cursor *cursor)
+{
+    return %(s)s_cast(ovsdb_idl_index_data(CONST_CAST(struct ovsdb_idl_index_cursor*, cursor)));
+}''' % { 's' : structName }
+# End Index table related functions
         # Table columns.
         print "\nstruct ovsdb_idl_column %s_columns[%s_N_COLUMNS];" % (
             structName, structName.upper())
@@ -1021,6 +1135,10 @@ static void\n%s_columns_init(void)
             print "    c->mutable = %s;" % mutable
             print "    c->parse = %(s)s_parse_%(c)s;" % d
             print "    c->unparse = %(s)s_unparse_%(c)s;" % d
+            if isColumnIndexable(column):
+                print '    c->compare = %(s)s_index_%(c)s_cmp;' % d
+            else:
+                print '    c->compare = NULL;'
         print "}"
 
     # Table classes.
diff --git a/ovsdb/ovsdb-idlc.in.orig b/ovsdb/ovsdb-idlc.in.orig
index 88b1ec3..828f596 100755
--- a/ovsdb/ovsdb-idlc.in.orig
+++ b/ovsdb/ovsdb-idlc.in.orig
@@ -255,6 +255,22 @@ struct %(s)s *%(s)s_insert(struct ovsdb_idl_txn *);
                                                structName.upper(), func)
             print
 
+        # On-demand fetching functions
+        print 'bool %(s)s_is_row_fetch_pending(const struct %(s)s *);\n' % {'s': structName}
+        for columnName, column in sorted(table.columns.iteritems()):
+            print 'bool %(s)s_is_%(c)s_fetch_pending(struct ovsdb_idl *);' % {'s': structName, 'c': columnName}
+        print '\nbool %(s)s_is_table_fetch_pending(struct ovsdb_idl *);\n' % {'s': structName}
+
+        for columnName, column in sorted(table.columns.iteritems()):
+            print 'void %(s)s_fetch_%(c)s(struct ovsdb_idl *, const struct %(s)s *);' % {'s': structName, 'c': columnName}
+        print
+
+        for columnName, column in sorted(table.columns.iteritems()):
+            print 'void %(s)s_fetch_col_%(c)s(struct ovsdb_idl *);' % {'s': structName, 'c': columnName}
+        print
+
+        print 'void %(s)s_fetch_table(struct ovsdb_idl *);\n' % {'s': structName, 'c': columnName}
+
         for columnName, column in sorted(table.columns.iteritems()):
             print 'void %(s)s_verify_%(c)s(const struct %(s)s *);' % {'s': structName, 'c': columnName}
 
@@ -624,6 +640,90 @@ struct %(s)s *
         't': tableName,
         'T': tableName.upper()}
 
+        # On-demand fetching functions.
+        print '''
+/* Verify if there is a pending fetch for 'rec'. */
+bool
+%(s)s_is_row_fetch_pending(const struct %(s)s *rec)
+{
+    ovs_assert(inited);
+    return ovsdb_idl_is_row_fetch_pending(CONST_CAST(struct ovsdb_idl_row *,
+                                                     &rec->header_));
+}''' % {'s': structName }
+
+        for columnName, column in sorted(table.columns.iteritems()):
+            print '''
+/* Verify if there is a pending fetch for '%(c)s' column. */
+bool
+%(s)s_is_%(c)s_fetch_pending(struct ovsdb_idl* idl)
+{
+    ovs_assert(inited);
+    return ovsdb_idl_is_column_fetch_pending(idl,
+                                             &%(p)stable_classes[%(P)sTABLE_%(T)s],
+                                             &%(s)s_col_%(c)s);
+}''' % {'s': structName,
+        'c': columnName,
+        'p': prefix,
+        'P': prefix.upper(),
+        't': tableName,
+        'T': tableName.upper()
+        }
+
+        print '''
+/* Verify if there is a pending fetch for table %(t)s. */
+bool
+%(s)s_is_table_fetch_pending(struct ovsdb_idl *idl)
+{
+    return ovsdb_idl_is_table_fetch_pending(idl, &%(p)stable_classes[%(P)sTABLE_%(T)s]);
+}
+''' % {'s': structName,
+       'p': prefix,
+       'P': prefix.upper(),
+       't': tableName,
+       'T': tableName.upper()}
+
+        for columnName, column in sorted(table.columns.iteritems()):
+            print '''
+/* Requests to fetch %(c)s for the specified 'rec'. */
+void
+%(s)s_fetch_%(c)s(struct ovsdb_idl *idl, const struct %(s)s *rec)
+{
+    ovs_assert(inited);
+    ovsdb_idl_fetch_row(idl,
+                        CONST_CAST(struct ovsdb_idl_row *, &rec->header_),
+                        &%(s)s_col_%(c)s);
+}''' % {'s': structName, 'c': columnName }
+
+
+        for columnName, column in sorted(table.columns.iteritems()):
+            print '''
+/* Requests to fetch the column '%(c)s' */
+void
+%(s)s_fetch_col_%(c)s(struct ovsdb_idl *idl)
+{
+    ovsdb_idl_fetch_column(idl,
+                           &%(p)stable_classes[%(P)sTABLE_%(T)s],
+                           &%(s)s_col_%(c)s);
+}''' % {'s': structName,
+        'c': columnName,
+        'p': prefix,
+        'P': prefix.upper(),
+        'T': tableName.upper()}
+
+        print '''
+/* Requests to fetch all the on-demand columns for the specified 'table'. */
+void
+%(s)s_fetch_table(struct ovsdb_idl *idl)
+{
+    ovs_assert(inited);
+    ovsdb_idl_fetch_table(idl,
+                          &%(p)stable_classes[%(P)sTABLE_%(T)s]);
+}''' % {'s': structName,
+        'p': prefix,
+        'P': prefix.upper(),
+        'T': tableName.upper()}
+        print
+
         # Verify functions.
         for columnName, column in sorted(table.columns.iteritems()):
             print '''
diff --git a/tests/.gitignore b/tests/.gitignore
index f4540a3..ed017c1 100644
--- a/tests/.gitignore
+++ b/tests/.gitignore
@@ -38,6 +38,7 @@
 /test-rstp
 /test-sflow
 /test-sha1
+/test-skiplist
 /test-stp
 /test-strtok_r
 /test-timeval
diff --git a/tests/automake.mk b/tests/automake.mk
index 6ce503f..6413b56 100644
--- a/tests/automake.mk
+++ b/tests/automake.mk
@@ -167,6 +167,7 @@ valgrind_wrappers = \
 	tests/valgrind/test-reconnect \
 	tests/valgrind/test-rstp \
 	tests/valgrind/test-sha1 \
+	tests/valgrind/test-skiplist \
 	tests/valgrind/test-stp \
 	tests/valgrind/test-type-props \
 	tests/valgrind/test-unix-socket \
@@ -312,6 +313,7 @@ tests_ovstest_SOURCES = \
 	tests/test-rstp.c \
 	tests/test-sflow.c \
 	tests/test-sha1.c \
+	tests/test-skiplist.c \
 	tests/test-stp.c \
 	tests/test-util.c \
 	tests/test-uuid.c \
diff --git a/tests/library.at b/tests/library.at
index d5dcb12..4542156 100644
--- a/tests/library.at
+++ b/tests/library.at
@@ -51,6 +51,17 @@ AT_CHECK([ovstest test-sha1], [0], [.........
 ])
 AT_CLEANUP
 
+AT_SETUP([test skiplist])
+AT_KEYWORDS([skiplist])
+AT_CHECK([ovstest test-skiplist], [0], [skiplist insert
+skiplist delete
+skiplist find
+skiplist forward_to
+skiplist random
+
+])
+AT_CLEANUP
+
 AT_SETUP([test type properties])
 AT_CHECK([test-type-props])
 AT_CLEANUP
diff --git a/tests/test-skiplist.c b/tests/test-skiplist.c
new file mode 100644
index 0000000..291ff26
--- /dev/null
+++ b/tests/test-skiplist.c
@@ -0,0 +1,212 @@
+/* Copyright (C) 2016 Hewlett Packard Enterprise Development LP
+ * All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License. You may obtain
+ * a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+/* A non-exhaustive test for some of the functions and macros declared in
+ * skiplist.h. */
+
+#include <config.h>
+#undef NDEBUG
+#include <assert.h>
+#include <stdio.h>
+#include <string.h>
+#include "ovstest.h"
+#include "skiplist.h"
+#include "random.h"
+#include "util.h"
+
+static void
+test_skiplist_main(int argc OVS_UNUSED, char *argv[] OVS_UNUSED);
+
+static int test_skiplist_cmp(const void *a, const void *b, const void *conf);
+
+static void test_skiplist_insert(void);
+static void test_skiplist_delete(void);
+static void test_skiplist_find(void);
+static void test_skiplist_forward_to(void);
+static void test_skiplist_random(void);
+
+static int test_skiplist_cmp(const void *a, const void *b, const void *conf OVS_UNUSED)
+{
+    const int *n = (const int *)a;
+    const int *m = (const int *)b;
+    return (*n > *m) - (*n < *m);
+}
+
+static void test_skiplist_insert(void)
+{
+    struct skiplist *sl = skiplist_create(14, test_skiplist_cmp, NULL);
+    skiplist_set_free_func(sl, free);
+    int i;
+    int *integer;
+
+    /* Insert a million rows */
+    for(i = 0; i < 1000000; i++){
+        integer = malloc(sizeof(int));
+        *integer = i;
+        skiplist_insert(sl, integer);
+    }
+
+    /* Check that the skiplist maintains the list sorted */
+    struct skiplist_node *node = skiplist_first(sl);
+
+    for(i = 0; i < 1000000; i++){
+        integer = (int*)skiplist_get_data(node);
+        assert(i == *integer);
+        node = skiplist_next(node);
+    }
+
+    skiplist_destroy(sl);
+}
+
+static void test_skiplist_delete(void)
+{
+    struct skiplist *sl = skiplist_create(3, test_skiplist_cmp, NULL);
+    int a, b, c;
+    a = 1;
+    b = 2;
+    c = 3;
+    /* Insert rows */
+    skiplist_insert(sl, &a);
+    skiplist_insert(sl, &c);
+    skiplist_insert(sl, &b);
+
+    /* Check that the items exists */
+    assert(a == *(int *)skiplist_get_data(skiplist_find(sl, &a)));
+    assert(b == *(int *)skiplist_get_data(skiplist_find(sl, &b)));
+    assert(c == *(int *)skiplist_get_data(skiplist_find(sl, &c)));
+
+    /* Delete b*/
+    skiplist_delete(sl, &b);
+
+    /* Check that the items doesn't exists */
+    assert(a == *(int *)skiplist_get_data(skiplist_find(sl, &a)));
+    assert(NULL == skiplist_get_data(skiplist_find(sl, &b)));
+    assert(c == *(int *)skiplist_get_data(skiplist_find(sl, &c)));
+
+    skiplist_destroy(sl);
+}
+
+static void test_skiplist_find(void)
+{
+    struct skiplist *sl = skiplist_create(14, test_skiplist_cmp, NULL);
+    skiplist_set_free_func(sl, free);
+
+    int i;
+    int *integer;
+
+    /* Insert a million of rows */
+    for(i = 0; i < 1000000; i++){
+        integer = malloc(sizeof(int));
+        *integer = i;
+        skiplist_insert(sl, integer);
+    }
+
+    /* Seek all the items */
+    for(i = 0; i < 1000000; i++){
+        integer = (int*)skiplist_get_data(skiplist_find(sl, &i));
+        assert(i == *integer);
+    }
+
+    skiplist_destroy(sl);
+}
+
+static void test_skiplist_forward_to(void)
+{
+    struct skiplist *sl = skiplist_create(3, test_skiplist_cmp, NULL);
+    int a, b, c, d, x;
+    a = 1;
+    b = 3;
+    c = 7;
+    d = 10;
+    /* Insert rows */
+    skiplist_insert(sl, &a);
+    skiplist_insert(sl, &c);
+    skiplist_insert(sl, &b);
+    skiplist_insert(sl, &d);
+
+    /* Check that forward_to returns the expected value */
+    x = a;
+    assert(a == *(int *)skiplist_get_data(skiplist_forward_to(sl, &x)));
+
+    x = 2;
+    assert(b == *(int *)skiplist_get_data(skiplist_forward_to(sl, &x)));
+
+    x = 5;
+    assert(c == *(int *)skiplist_get_data(skiplist_forward_to(sl, &x)));
+
+    x = 8;
+    assert(d == *(int *)skiplist_get_data(skiplist_forward_to(sl, &x)));
+
+    x = 15;
+    assert(NULL == (int *)skiplist_get_data(skiplist_forward_to(sl, &x)));
+
+    /* Destroy skiplist */
+    skiplist_destroy(sl);
+}
+
+static void
+test_skiplist_random(void)
+{
+    int j;
+    for(j=1; j<64; j++) {
+        struct skiplist *sl = skiplist_create(j, test_skiplist_cmp, NULL);
+        int total_numbers = 50;
+        int expected_count = 0;
+        int *numbers = malloc(sizeof(int) * total_numbers);
+        int i, op, element;
+        for(i = 0; i < total_numbers; i++){
+            numbers[i] = i;
+        }
+        random_init();
+        for(i = 0; i < total_numbers*1000; i++){
+            op = random_uint32() % 2;
+            element = random_range(total_numbers);
+            if(op == 0){
+                if(!skiplist_find(sl, &numbers[element])) {
+                    expected_count++;
+                }
+                skiplist_insert(sl, &numbers[element]);
+            } else {
+                if(skiplist_find(sl, &numbers[element])) {
+                    expected_count--;
+                }
+                skiplist_delete(sl, &numbers[element]);
+            }
+            ovs_assert(expected_count == skiplist_get_size(sl));
+        }
+
+        skiplist_destroy(sl);
+        free(numbers);
+    }
+}
+
+static void
+test_skiplist_main(int argc OVS_UNUSED, char *argv[] OVS_UNUSED)
+{
+    printf("skiplist insert\n");
+    test_skiplist_insert();
+    printf("skiplist delete\n");
+    test_skiplist_delete();
+    printf("skiplist find\n");
+    test_skiplist_find();
+    printf("skiplist forward_to\n");
+    test_skiplist_forward_to();
+    printf("skiplist random\n");
+    test_skiplist_random();
+    printf("\n");
+}
+
+OVSTEST_REGISTER("test-skiplist", test_skiplist_main);
-- 
2.1.4

